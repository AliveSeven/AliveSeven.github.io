<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AliveSeven&#39;s Blog</title>
  
  
  <link href="https://aliveseven.github.io/atom.xml" rel="self"/>
  
  <link href="https://aliveseven.github.io/"/>
  <updated>2022-12-17T16:00:04.999Z</updated>
  <id>https://aliveseven.github.io/</id>
  
  <author>
    <name>AliveSeven</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Options请求详解</title>
    <link href="https://aliveseven.github.io/posts/dd78f1f7/"/>
    <id>https://aliveseven.github.io/posts/dd78f1f7/</id>
    <published>2022-12-17T15:37:07.456Z</published>
    <updated>2022-12-17T16:00:04.999Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Options请求详解"><a href="#Options请求详解" class="headerlink" title="Options请求详解"></a>Options请求详解</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>Option请求就是预处理请求，一般是发生在跨域请求的时候，浏览器为了安全起见，会执行CORS预检请求，也就是Options请求。</li><li>HTTP 的 OPTIONS 方法用于获取目的资源所支持的通信选项。</li><li>在跨域请求时，浏览器会向服务器发起Options请求，从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。</li></ul><blockquote><p>某些请求不会触发CORS预检请求，这样的请求一般称为 “简单请求” ，而会触发预检的请求则是 “复杂请求” 。</p></blockquote><h2 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h2><ul><li>一般通过GET、HEAD、POST请求时，都是简单请求</li><li>请求中的任意 XMLHttpRequestUpload对象均没有注册任何事件监听器；</li><li>请求中没有使用 ReadableStream对象。</li><li>Content-Type 的值仅限于下列三者之一,即application/x-www-form-urlencoded、multipart/form-data、text/plain；</li></ul><h2 id="复杂请求"><a href="#复杂请求" class="headerlink" title="复杂请求"></a>复杂请求</h2><ul><li>通过PUT/DELETE/CONNECT/OPTIONS/TRACE/PATCH请求</li><li>Content-Type 的值不属于下列之一，即application/x-www-form-urlencoded、multipart/form-data、text/plain。</li></ul><h2 id="Options请求优化策略"><a href="#Options请求优化策略" class="headerlink" title="Options请求优化策略"></a>Options请求优化策略</h2><p>当发起跨域请求时，简单请求只发起1次请求；复杂请求则需要2次，先发起options请求，确认目标资源是否支持跨域，浏览器会根据服务端响应的header自动处理剩余的请求，如果响应支持跨域，则继续发出正常请求；不支持的话，会在控制台显示错误。</p><p>所以，当触发预检时，跨域请求便会发送2次请求，增加请求次数，同时，也延迟了请求真正发起的时间，会严重地影响性能。</p><h3 id="优化方法一"><a href="#优化方法一" class="headerlink" title="优化方法一"></a>优化方法一</h3><ul><li>用其它的跨域方式做跨域请求，将复杂请求转为简单请求，比如JSONP等</li><li>对 options 请求进行缓存</li></ul><blockquote><p>文章参考：<a href="https://blog.csdn.net/kjssjj12/article/details/125298347">https://blog.csdn.net/kjssjj12/article/details/125298347</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Options请求详解&quot;&gt;&lt;a href=&quot;#Options请求详解&quot; class=&quot;headerlink&quot; title=&quot;Options请求详解&quot;&gt;&lt;/a&gt;Options请求详解&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;head</summary>
      
    
    
    
    <category term="前端" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="https://aliveseven.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Vue通过不同的值改变class</title>
    <link href="https://aliveseven.github.io/posts/6df76c49/"/>
    <id>https://aliveseven.github.io/posts/6df76c49/</id>
    <published>2022-12-14T15:10:33.302Z</published>
    <updated>2022-12-14T15:14:07.731Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue通过不同的值改变class"><a href="#Vue通过不同的值改变class" class="headerlink" title="Vue通过不同的值改变class"></a>Vue通过不同的值改变class</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>我们在进行组件化开发的时候，可能想让当前类有不同的样式，或者是多种样式。</li><li>亦或是我们想要通过<strong>props</strong>来进行父组件给子组件传值，然后子组件根据传过来的值进行判断，不同的值对应不同的样式（有点像组件库中的size）</li><li>这时候就引出上题了</li></ul><h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><p>其实很简单，只需要给class加上<code>&#123; &#39;类名&#39; : &#39;条件&#39; &#125;</code>即可，比如</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;pop&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;&#123; popB : popAct == true&#125;&quot;</span> &gt;</span></span><br></pre></td></tr></table></figure><p>这里就给盒子加入pop 和 popB的类名了，popB是**(popAct == true)**这个条件为true的时候才触发，也就是popAct == false的时候，这个时候就没有popB这个类名了。</p><p>即：</p><ul><li>当popAct == true的时候，class = “pop popB”</li><li>当popAct == false的时候，不满足触发popB的条件，class = “pop”</li></ul><h2 id="多个条件的情况下"><a href="#多个条件的情况下" class="headerlink" title="多个条件的情况下"></a>多个条件的情况下</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;[&#123; big : size == &#x27;da&#x27; &#125;,&#123; mid : size == &#x27;zhong&#x27;&#125;,&#123;small : size==&#x27;xiao&#x27;&#125;]&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的代码的意思：</p><ul><li>当size这个变量等于’da’的时候，即size == ‘da’ 为true的时候，class=”big”</li><li>当size这个变量等于’zhong’的时候，即size == ‘zhong’ 为true的时候，class=”mid”</li><li>当size这个变量等于’xiao’的时候，即size == ‘xiao’ 为true的时候，class=”small”</li></ul><p>这样看是不是很容易理解了。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Vue通过不同的值改变class&quot;&gt;&lt;a href=&quot;#Vue通过不同的值改变class&quot; class=&quot;headerlink&quot; title=&quot;Vue通过不同的值改变class&quot;&gt;&lt;/a&gt;Vue通过不同的值改变class&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="前端" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/Vue/"/>
    
    
    <category term="前端" scheme="https://aliveseven.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://aliveseven.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>css中的 /deep/ 的作用</title>
    <link href="https://aliveseven.github.io/posts/d8bf5e98/"/>
    <id>https://aliveseven.github.io/posts/d8bf5e98/</id>
    <published>2022-12-09T16:49:07.089Z</published>
    <updated>2022-12-14T14:53:53.390Z</updated>
    
    <content type="html"><![CDATA[<h1 id="css中的-deep-的作用"><a href="#css中的-deep-的作用" class="headerlink" title="css中的 /deep/ 的作用"></a>css中的 /deep/ 的作用</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们在用Vue进行模块化、组件化开发的时候，可以通过给样式加上scoped，避免了父组件的样式影响了子组件的样式。而<code>/deep/</code> 的作用和scoped也有点类似。</p><h2 id="css中的scoped"><a href="#css中的scoped" class="headerlink" title="css中的scoped"></a>css中的scoped</h2><p>使用<code>&lt;style scoped&gt;</code>，这样父组件中如果有跟子组件相同的class名称或者使用选择器的时候，就不会影响到子组件的样式。</p><p>通过给style添加<code>scoped</code>，使它的<strong>css只作用于当前组件的元素。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line">    <span class="selector-class">.box</span>&#123;</span><br><span class="line">        <span class="attribute">color</span>:<span class="string">&#x27;#999&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="深度选择器-deep"><a href="#深度选择器-deep" class="headerlink" title="深度选择器 /deep/"></a>深度选择器 /deep/</h2><p>使用了外界的组件（比如像Element-UI、Ant Design、Vant等组件库中的组件）或者自己开发一个组件，修改一处就可能会影响到用这个组件的所有样式，所以就需要有一个方法或者方式，<strong>既不影响到别的地方</strong>，<strong>又能修改子组件在当前的样式</strong>。<code>/deep/</code>就能实现。</p><p>比如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> /deep/ <span class="selector-class">.el-tabs__item</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#303133</span> <span class="meta">!important</span>;  // !important 优先级</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="v-deep"><a href="#v-deep" class="headerlink" title="::v-deep"></a>::v-deep</h2><p>在vue2中，我们舍弃了’&gt;&gt;&gt;’ 和 / deep /，改用**::v-deep**来进行深度选择</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">::v-deep .el-col &#123;</span><br><span class="line"><span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="v-deep-1"><a href="#v-deep-1" class="headerlink" title="v-deep"></a>v-deep</h2><p>而在vue3中，官方推荐使用**v-deep(.className)**来进行深度选择，当然::v-deep依旧也可以使用，不过可以采用缩写的方式来进行css编译—— <strong>:deep</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">::<span class="built_in">v-deep</span>(.el-col) &#123;</span><br><span class="line"><span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 缩写</span><br><span class="line">:<span class="built_in">deep</span>(.el-col) &#123;</span><br><span class="line"><span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;css中的-deep-的作用&quot;&gt;&lt;a href=&quot;#css中的-deep-的作用&quot; class=&quot;headerlink&quot; title=&quot;css中的 /deep/ 的作用&quot;&gt;&lt;/a&gt;css中的 /deep/ 的作用&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="前端" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="https://aliveseven.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="CSS" scheme="https://aliveseven.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Vue中$emit的用法</title>
    <link href="https://aliveseven.github.io/posts/3900e167/"/>
    <id>https://aliveseven.github.io/posts/3900e167/</id>
    <published>2022-12-07T15:38:31.955Z</published>
    <updated>2022-12-07T15:50:06.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue中-emit的用法"><a href="#Vue中-emit的用法" class="headerlink" title="Vue中$emit的用法"></a>Vue中$emit的用法</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在开发的过程中，我们很多时候都需要用到组件之间的通信，父组件可以通过props把数据传给子组件，这是父→子的通信。同样，也有子→父的通信方式，$emit就是其中的一种。子组件可以通过$emit，让父组件监听到自定义事件。</p><h2 id="Vue2中"><a href="#Vue2中" class="headerlink" title="Vue2中"></a>Vue2中</h2><blockquote><p>使用：比如子组件使用$emit定义一个 自定义事件FuncHello</p></blockquote><ul><li>子组件在方法中设定一个sendByEmit方法，方法中使用$emit向父组件发出启动’FuncHello’的方法，传入的参数是data。</li><li>加入一个按钮，点击按钮触发sendByEmit函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;button @click=&quot;sendByEmit()&quot;&gt;按下发送$emit&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">    name :  &#x27;Children&#x27;,</span><br><span class="line">    props : &#123;</span><br><span class="line">        msg : String</span><br><span class="line">    &#125;,</span><br><span class="line">    methods : &#123;</span><br><span class="line">        sendByEmit()&#123;</span><br><span class="line">            let data = &#x27;hello&#x27;</span><br><span class="line">            this.$emit(&#x27;FuncHello&#x27;, data)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>父组件中引入子组件，通过v-on或者是@引入自定义的方法FuncHello</p></blockquote><ul><li>加入一个h1标签，用v-for的方法将数据中的text数组遍历出来。</li><li>声明一个getEmitData方法，用于接受FuncHello方法传过来的数据，对数据进行操作，这里是把数据推到text数组里面</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1 v-for=&quot;(item, index) in text&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">            &#123;&#123; item &#125;&#125;</span><br><span class="line">        &lt;/h1&gt;</span><br><span class="line">        &lt;Children @FuncHello=&quot;getEmitData&quot; &gt;&lt;/Children&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Children from &#x27;@/components/Children.vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    name : &#x27;Father&#x27;,</span><br><span class="line">    components : &#123;</span><br><span class="line">        Children</span><br><span class="line">    &#125;, </span><br><span class="line">    data() &#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            text : [&#x27;12345&#x27;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods : &#123;</span><br><span class="line">        getEmitData(data)&#123;</span><br><span class="line">            this.text.push(data)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h8voh8ucx5g30b40kv3zn.gif"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Vue中-emit的用法&quot;&gt;&lt;a href=&quot;#Vue中-emit的用法&quot; class=&quot;headerlink&quot; title=&quot;Vue中$emit的用法&quot;&gt;&lt;/a&gt;Vue中$emit的用法&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;</summary>
      
    
    
    
    <category term="前端" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/Vue/"/>
    
    
    <category term="前端" scheme="https://aliveseven.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://aliveseven.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>XSS和CSRF的概念</title>
    <link href="https://aliveseven.github.io/posts/9509af57/"/>
    <id>https://aliveseven.github.io/posts/9509af57/</id>
    <published>2022-12-02T12:35:56.065Z</published>
    <updated>2022-12-07T14:53:54.283Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XSS和CSRF的概念"><a href="#XSS和CSRF的概念" class="headerlink" title="XSS和CSRF的概念"></a>XSS和CSRF的概念</h1><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>全称Cross Site Scripting，名为<strong>跨站脚本攻击</strong>，黑客将恶意脚本代码植入到页面中从而实现盗取用户信息等操作。</p><p>恶意攻击者往 Web 页面里嵌入恶意的客户端脚本，当用户浏览此网页时，脚本就会在用户的浏览器上执行，进而达到攻击者的目的。比如获取用户的 Cookie、导航到恶意网站、携带木马等。</p><h3 id="注入方法"><a href="#注入方法" class="headerlink" title="注入方法"></a>注入方法</h3><p>任何可以输入的地方都有可能引起XSS攻击，包括URL</p><ul><li>在HTML内嵌的文本中，恶意内容以script标签形成注入</li><li>在内联的JavaScript中，拼接的数据突破了原本的限制（字符串，变量，方法名）等</li><li>在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签</li><li>在标签的 <code>href、src</code> 等属性中，包含 <code>javascript:</code> (伪协议)等可执行代码。</li><li>在 <code>onload、onerror、onclick</code> 等事件中，注入不受控制代码。</li></ul><h3 id="XSS的分类"><a href="#XSS的分类" class="headerlink" title="XSS的分类"></a>XSS的分类</h3><p>可分为存储型、反射性和DOM型三种</p><h3 id="预防XSS"><a href="#预防XSS" class="headerlink" title="预防XSS"></a>预防XSS</h3><ul><li>前端和后端一起做数据过滤，前端可以使用axios拦截器，在发送请求前先过滤一遍数据，后端在接收时再过滤一遍。</li><li>尽量使用post，使用get方式时对路径长度进行限制</li><li>对输入、输出结果进行过滤和必要的转义</li></ul><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p><strong>跨站请求伪造</strong>（Cross-site request forgery），就是攻击者伪装成用户身份来执行一些非用户自愿的恶意以及非法操作。</p><p>典型的CSRF攻击：</p><ul><li>用户A经常访问网站B，然后攻击者发现网站B中存在CSRF的漏洞，加以利用，勾引用户A访问攻击者写好的危险网站C，此时用户A的cookie等信息还没有失效，危险网站C中有向网站B的非法请求，此时用户的信息就容易泄露了。</li><li>通常请求被放置在img标签的src中，当用户访问了包含这个标签的网页时，浏览器会自动向src中的地址提交一次http请求</li><li>通过夸张的广告诱导用户点击链接，跳转到危险的网站，该网站自动自动发送请求，冒充用户执行相应的操作。</li></ul><h3 id="预防CSRF"><a href="#预防CSRF" class="headerlink" title="预防CSRF"></a>预防CSRF</h3><ul><li>验证码</li><li>设置CSRF Token，或使用TokenId令牌</li><li>为Set-Cookie响应头新增Samesite属性，Samesite=Strict</li></ul><h2 id="CSRF和XSS的区别"><a href="#CSRF和XSS的区别" class="headerlink" title="CSRF和XSS的区别"></a>CSRF和XSS的区别</h2><ol><li>CSRF需要登陆后操作，XSS不需要</li><li>CSRF是请求页面api来实现非法操作，XSS是向当前页面植入js脚本来修改页面内容。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;XSS和CSRF的概念&quot;&gt;&lt;a href=&quot;#XSS和CSRF的概念&quot; class=&quot;headerlink&quot; title=&quot;XSS和CSRF的概念&quot;&gt;&lt;/a&gt;XSS和CSRF的概念&lt;/h1&gt;&lt;h2 id=&quot;XSS&quot;&gt;&lt;a href=&quot;#XSS&quot; class=&quot;he</summary>
      
    
    
    
    <category term="前端" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="https://aliveseven.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Vue3+TypeScript实现节流</title>
    <link href="https://aliveseven.github.io/posts/67f65b3c/"/>
    <id>https://aliveseven.github.io/posts/67f65b3c/</id>
    <published>2022-11-28T15:31:54.116Z</published>
    <updated>2022-11-28T15:35:25.030Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue3-TypeScript实现节流"><a href="#Vue3-TypeScript实现节流" class="headerlink" title="Vue3+TypeScript实现节流"></a>Vue3+TypeScript实现节流</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>在Vue中可以使用闭包的方法实现防抖节流。</li><li>同样也可以用lodash函数库中的_.throttle() /  _.debounce()实现节流防抖</li><li>亦或是使用Vue中的directive()自定义指令，这样做的好处可以随处使用（建议）</li></ol><h2 id="自定义指令v-throttle"><a href="#自定义指令v-throttle" class="headerlink" title="自定义指令v-throttle"></a>自定义指令v-throttle</h2><ol><li>首先在src目录下新建一个throttle的文件夹</li><li>新建index.ts文件</li><li>写入下面的代码</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">App</span>, <span class="title class_">Directive</span> &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出节流函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">setupThrottleDriective</span>(<span class="params">app : App</span>) &#123;</span><br><span class="line">  <span class="comment">/** 定时器 */</span></span><br><span class="line">  <span class="keyword">let</span> timer : <span class="built_in">any</span> = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 节流，第二个参数就是要进行节流的时间间隔</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">throttleELfun</span>(<span class="params">el : HTMLElement, throttleTime = <span class="number">5000</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 监听元素，捕获事件</span></span><br><span class="line">    el.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">event:Event</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">        timer = <span class="variable language_">window</span>.<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          timer = <span class="literal">null</span></span><br><span class="line">        &#125;, throttleTime)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 阻止同层级事件的冒泡</span></span><br><span class="line">        event?.<span class="title function_">stopImmediatePropagation</span>()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> throttleDirective : <span class="title class_">Directive</span>&lt;<span class="title class_">HTMLElement</span>&gt; = &#123;</span><br><span class="line">    <span class="comment">// 载入前(完成了data和el数据初始化)，执行下面的函数</span></span><br><span class="line">    <span class="title function_">beforeMount</span>(<span class="params">el, bingding</span>) &#123;</span><br><span class="line">      <span class="title function_">throttleELfun</span>(el, bingding.<span class="property">value</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新建一个新的指令为throttle</span></span><br><span class="line">  app.<span class="title function_">directive</span>(<span class="string">&#x27;throttle&#x27;</span>, throttleDirective)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全局导入指令"><a href="#全局导入指令" class="headerlink" title="全局导入指令"></a>全局导入指令</h2><ol><li>打开项目中的main.ts文件</li><li>引入函数setupThrottleDriective()</li><li>传入参数</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> setupThrottleDriective <span class="keyword">from</span> <span class="string">&#x27;./throttle&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./assets/base.css&#x27;</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">setupThrottleDriective</span>(app)</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h8l9equg68j30l307n77p.jpg"></p><blockquote><p>然后即可直接在组件中使用了，使用之后会对该HTML元素进行监听，在一定的时间间隔里面多次执行，只会执行一次</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Vue3-TypeScript实现节流&quot;&gt;&lt;a href=&quot;#Vue3-TypeScript实现节流&quot; class=&quot;headerlink&quot; title=&quot;Vue3+TypeScript实现节流&quot;&gt;&lt;/a&gt;Vue3+TypeScript实现节流&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="前端" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/Vue/"/>
    
    <category term="TypeScript" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/TypeScript/"/>
    
    
    <category term="前端" scheme="https://aliveseven.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://aliveseven.github.io/tags/Vue/"/>
    
    <category term="TypeScript" scheme="https://aliveseven.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>Vue中$nextTick的作用</title>
    <link href="https://aliveseven.github.io/posts/f4a37cd9/"/>
    <id>https://aliveseven.github.io/posts/f4a37cd9/</id>
    <published>2022-11-23T18:35:06.165Z</published>
    <updated>2022-11-23T18:39:06.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue中-nextTick的作用"><a href="#Vue中-nextTick的作用" class="headerlink" title="Vue中$nextTick的作用"></a>Vue中$nextTick的作用</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有些时候，我们在做了某些回调方法或者说是作了某些修改数据的操作之后，会发现数据在视图上没有立即更新，出现这种情况如何解决，就用到了$nextTick了。</p><p>作用：它可以在下次dom更新循环结束之后执行延迟回调，在修改数据之后立即使用该方法，就可以获取更新之后的dom。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>在 Vue 的文档中，说明了 Vue 是<strong>异步</strong>执行 dom 更新的。然后异步任务的执行机制，是等所有同步任务执行完之后，浏览器读取任务队列中的异步任务，开始执行。当任务队列中的任务执行完毕之后，算一轮事件循环，这个时候Vue才会进行dom视图更新。</p><blockquote><p>Vue 在修改数据后，视图不会立刻更新，而是等<strong>同一事件循环</strong>中的所有数据变化完成之后，再统一进行视图更新。</p></blockquote><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>在vue的生命周期 <code>created()</code> 钩子函数中进行 dom 操作，一定要放在 <code>$nextTick()</code> 函数中执行。在 <code>created()</code> 钩子函数执行的时候 DOM 其实并未进行任何渲染，而此时进行 DOM 操作无异于徒劳，所以此处一定要将 DOM 操作的代码放进 <code>nextTick()</code> 的回调函数中。</li><li>在数据变化后要执行某个操作，而这个操作需要使用随数据改变而改变的 DOM 结构的时候，这个操作都应该放进 Vue.nextTick()的回调函数中。</li><li>获取元素宽度，需要在 DOM 渲染完毕后执行</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Vue中-nextTick的作用&quot;&gt;&lt;a href=&quot;#Vue中-nextTick的作用&quot; class=&quot;headerlink&quot; title=&quot;Vue中$nextTick的作用&quot;&gt;&lt;/a&gt;Vue中$nextTick的作用&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="前端" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/Vue/"/>
    
    
    <category term="前端" scheme="https://aliveseven.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://aliveseven.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>单链表反转</title>
    <link href="https://aliveseven.github.io/posts/6b96a7/"/>
    <id>https://aliveseven.github.io/posts/6b96a7/</id>
    <published>2022-11-23T15:31:31.944Z</published>
    <updated>2022-11-23T18:51:02.994Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>先声明一个新的节点pre = null，然后声明一个新的节点cur = head，把头节点赋值给它，然后声明一个中间节点temp = cur.next，也就是将下一个节点赋值给中间节点temp</p><p>然后，赋值完之后再对cur.next进行操作，领cur.next = pre，也就是将当前节点的下一个节点，就是当前传过来的节点，比如一开始不是传入头节点吗，那么这时就让头节点的下一个节点指向pre，也就是null，然后再对pre进行操作，领pre = cur，主要是为下一次的迭代做好铺路，再让cur = temp，就是将开头中间节点保存的那个节点赋值给cur。以上的这些操作一直循环执行，直到cur指向null</p><p>最后，这些操作完之后，此时pre就是最后的节点了，返回pre</p><h2 id="案例代码"><a href="#案例代码" class="headerlink" title="案例代码"></a>案例代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseList = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.<span class="property">next</span> == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明中间变量</span></span><br><span class="line">        <span class="keyword">let</span> cur = head</span><br><span class="line">        <span class="keyword">let</span> pre = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">let</span> next = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 把下一个节点赋给next</span></span><br><span class="line">            next = cur.<span class="property">next</span></span><br><span class="line">            <span class="comment">// 再把下一个节点赋予中间值pre</span></span><br><span class="line">            cur.<span class="property">next</span> = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = next</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h8fn4jh21gj30r30os79m.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;实现思路&quot;&gt;&lt;a href=&quot;#实现思路&quot; class=&quot;headerlink&quot; title=&quot;实现思路&quot;&gt;&lt;/a&gt;实现思路&lt;/h2&gt;&lt;p&gt;先声明一个新的节点pre = null，然后声明一个新的节点cur = head，把头节点赋值给它，然后声明一个中间节点te</summary>
      
    
    
    
    <category term="后端" scheme="https://aliveseven.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="算法" scheme="https://aliveseven.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Vue3通过Vite动态引入图片:scr</title>
    <link href="https://aliveseven.github.io/posts/b0c5b807/"/>
    <id>https://aliveseven.github.io/posts/b0c5b807/</id>
    <published>2022-11-18T13:12:01.255Z</published>
    <updated>2022-11-18T14:32:29.016Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue3通过Vite动态引入图片-scr"><a href="#Vue3通过Vite动态引入图片-scr" class="headerlink" title="Vue3通过Vite动态引入图片:scr"></a>Vue3通过Vite动态引入图片:scr</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很多时候我们在开发的时候需要动态引入图片，在Vue2中可以用require()来实现这个，但是Vue3中却不支持require()。</p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><ul><li>给scr绑定一个函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img :src=&quot;getImageUrl(img)&quot; alt=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure><ul><li>获取照片的函数</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getImageUrl</span>(<span class="params">img : <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">`../assets/Img/<span class="subst">$&#123;img&#125;</span>.jpg`</span>, <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>).<span class="property">href</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="new-URL"><a href="#new-URL" class="headerlink" title="new URL()"></a>new URL()</h2><ul><li>用于创建一个新 URL 对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title function_">URL</span>(url, [base])</span><br></pre></td></tr></table></figure><ul><li>url —— 完整的 URL，或者仅路径（如果设置了 base）</li><li>base —— 可选的 base URL：如果设置了此参数，且参数 url 只有路径，则会根据这个 base 生成 URL。</li><li><code>import.meta.url</code>是base url（根链接）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Vue3通过Vite动态引入图片-scr&quot;&gt;&lt;a href=&quot;#Vue3通过Vite动态引入图片-scr&quot; class=&quot;headerlink&quot; title=&quot;Vue3通过Vite动态引入图片:scr&quot;&gt;&lt;/a&gt;Vue3通过Vite动态引入图片:scr&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="前端" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/Vue/"/>
    
    
    <category term="前端" scheme="https://aliveseven.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://aliveseven.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>事件循环机制</title>
    <link href="https://aliveseven.github.io/posts/6628f169/"/>
    <id>https://aliveseven.github.io/posts/6628f169/</id>
    <published>2022-11-14T16:43:23.931Z</published>
    <updated>2022-11-21T13:58:00.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事件循环机制"><a href="#事件循环机制" class="headerlink" title="事件循环机制"></a>事件循环机制</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JavaScript是一种单线程的，为了利用好资源和任务分配，JS将任务分为同步任务和异步任务，<strong>而事件循环就是规定了执行任务的顺序。</strong></p><h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><p>事件循环机制就是按照以下的顺序模式来循环执行JS中的任务事件</p><p>顺序如下：</p><ol><li>同步先执行</li><li>异步（微任务 &gt; dom渲染 &gt; 宏任务，然后又继续去找有没微任务）</li></ol><h2 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h2><ul><li>promise.then（new promise构造函数是同步）、async/await。</li><li>process.nextTick</li><li>Promise.catch</li><li>resove/reject</li><li>MutationObserver</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><blockquote><p>Promise是异步的，是指他的then()和catch()方法，<strong>Promise本身还是同步的</strong>，所以遇到Promise还是先执行的Promise同步代码。（同步优先）</p></blockquote><h2 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h2><ul><li>setTimeout</li><li>setInterval</li><li>setImmediate</li><li>ajax请求</li><li>dom事件</li><li>script块</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>先执行同步代码，</li><li>遇到异步宏任务则将异步宏任务放入宏任务队列中，</li><li>遇到异步微任务则将异步微任务放入微任务队列中，</li><li>当所有同步代码执行完毕后，再将异步微任务从【队列】中调入【主线程】执行，</li><li>微任务执行完毕后再将异步宏任务从【队列】中调入【主线程】执行，<br>一直循环直至所有任务执行完毕。</li></ol><p>同步（Promise）&gt;异步（微任务（process.nextTick ，Promises.then，Promise.catch ，resove/reject，MutationObserver) &gt; 宏任务（setTimeout，setInterval，setImmediate））</p><p>注意 <code>new Promise() </code>是同步方法，<code>resolve</code>才是异步方法。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.程序开头，主线程，先执行，输出&#x27;script start&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.执行函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 3.1 执行await函数async2，也就是promise.then()</span></span><br><span class="line">    <span class="comment">// 3.4 执行完第一个await函数之后，微任务队列中还有一个任务，暂时跳出async函数</span></span><br><span class="line">    <span class="comment">// 3.5 输出&#x27;async1 end&#x27;，保留async1函数的上下文，然后跳出async1函数</span></span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">async2</span>()</span><br><span class="line">    <span class="comment">// 5.拿回执行权，输出</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 3.2 开始执行任务，输出 &#x27;async2 end&#x27;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async2 end&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.3 promise.resolve().then()，先加入微任务队列中，等待下一轮事件循环执行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async2 end1&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.开始调用async函数</span></span><br><span class="line"><span class="title function_">async1</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有微任务执行完，开始执行宏任务</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 new Promise是同步的，先执行同步</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 4.1 输出 &#x27;promise&#x27;，执行完这轮同步操作，继续往下看，还有没有同步的</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise&#x27;</span>)</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">&#125;)  <span class="comment">// 4.1 出现promise.then()，加入微任务队列，那么队列中就有两个微任务，按照先进先出的原则来执行，这一轮循环会先执行3.3 中的微任务，但是还是先执行同步任务先</span></span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">&#125;) <span class="comment">// 4.4 执行完上一个then()之后又产生一个新的微任务，继续输出，当前微任务队列执行完毕。执行权回到async1</span></span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.3 有同步任务，先执行同步任务，输出 &#x27;script end&#x27; ，再执行异步</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h8d3bi1ka3j30kw08v3z7.jpg"></p><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h8d3ekd507j30aw0kkwfk.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;事件循环机制&quot;&gt;&lt;a href=&quot;#事件循环机制&quot; class=&quot;headerlink&quot; title=&quot;事件循环机制&quot;&gt;&lt;/a&gt;事件循环机制&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="前端" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="JavaScript" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
    <category term="前端" scheme="https://aliveseven.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="JavaScript" scheme="https://aliveseven.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>宏任务和微任务详解</title>
    <link href="https://aliveseven.github.io/posts/eb14c465/"/>
    <id>https://aliveseven.github.io/posts/eb14c465/</id>
    <published>2022-11-14T13:52:43.384Z</published>
    <updated>2022-11-20T17:52:16.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="宏任务和微任务详解"><a href="#宏任务和微任务详解" class="headerlink" title="宏任务和微任务详解"></a>宏任务和微任务详解</h1><h2 id="JavaScript的单线程和任务队列"><a href="#JavaScript的单线程和任务队列" class="headerlink" title="JavaScript的单线程和任务队列"></a>JavaScript的单线程和任务队列</h2><ol><li>Js的内部引擎是单线程的，但是浏览器它是多线程的，单线程一意味着所有任务需要排队，前一个任务结束，才会执行后一个任务。</li><li>如果前一个任务耗时很长，后一个任务就不得不一直等待。而且有些时候，有些任务会挂载于<strong>等待状态</strong>，这个时候其实可以先去运行别的任务，等上一个任务需要再启动的时候，再来运行它。</li><li>于是，为了解决这个问题，有了同步任务（synchronous）和异步任务（asynchronous）。</li><li><strong>同步任务</strong>指的是，在<strong>主线程</strong>上，排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务</li><li><strong>异步任务</strong>指的是，不进入<strong>主线程</strong>，而进入“任务队列”（task queue）的任务，只有“任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</li></ol><p>这里借用一张图，就很好解释了同步和异步任务的执行过程</p><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h850mrn783j30tr0oidm6.jpg"></p><h2 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h2><p>前面我们已经介绍了同步任务和异步任务的执行过程，为了协调这些任务有条不紊地在主线程上执行，页面进程引入了<strong>消息队列和事件循环机制</strong>。</p><p><strong>宏任务（task）</strong>：就是JS 内部（任务队列里）的任务，严格按照时间顺序压栈和执行。比如 script(整体代码)、 setTimeOut、setInverter、setImmediate 、 MessageChannel等。</p><p><strong>微任务（Microtask ）</strong>：微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、<strong>宏任务结束之前</strong>。比如process.nextTick、Promise.then()、async/await（实际就是Promise）、MutationObserver（HTML5新特性）</p><p>主要的执行顺序是：</p><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h850n8sa2hj30tp0o9dl8.jpg"></p><h2 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h2><ol><li>在执行栈中执行一个宏任务。</li><li>执行过程中遇到微任务，<strong>将微任务添加到微任务队列中</strong>。</li><li>当前宏任务执行完毕，<strong>立即执行微任务队列中的任务。</strong></li><li>当前微任务队列中的任务执行完毕，检查渲染，GUI线程接管渲染。</li><li>渲染完毕后，js线程接管，开启下一次事件循环，执行下一次宏任务（事件队列中取）。</li></ol><p>借用一下别人的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;---start---&#x27;);//第一轮主线程</span><br><span class="line"> </span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;setTimeout&#x27;);  // 将回调代码放入个宏任务队列，第二轮宏任务执行</span><br><span class="line">&#125;, 0);</span><br><span class="line"> </span><br><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  console.log(&#x27;---Promise第一轮微任务同步执行---&#x27;);//第一轮微任务同步执行</span><br><span class="line">  resolve()</span><br><span class="line">&#125;).then(()=&gt;&#123;</span><br><span class="line">  console.log(&#x27;Promise.then实例成功回调执行&#x27;); // 将回调代码放入微任务队列，第一轮宏任务执行完后立即执行</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">console.log(&#x27;---end---&#x27;);//第一轮主线程结束</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h84zxbure1j30ai050dgf.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;宏任务和微任务详解&quot;&gt;&lt;a href=&quot;#宏任务和微任务详解&quot; class=&quot;headerlink&quot; title=&quot;宏任务和微任务详解&quot;&gt;&lt;/a&gt;宏任务和微任务详解&lt;/h1&gt;&lt;h2 id=&quot;JavaScript的单线程和任务队列&quot;&gt;&lt;a href=&quot;#JavaSc</summary>
      
    
    
    
    <category term="前端" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="面试" scheme="https://aliveseven.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="前端" scheme="https://aliveseven.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="JavaScript" scheme="https://aliveseven.github.io/tags/JavaScript/"/>
    
    <category term="面试" scheme="https://aliveseven.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Js实现元素拖拽</title>
    <link href="https://aliveseven.github.io/posts/e2d042a0/"/>
    <id>https://aliveseven.github.io/posts/e2d042a0/</id>
    <published>2022-11-12T06:24:13.951Z</published>
    <updated>2022-11-12T06:26:16.819Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Js实现元素拖拽"><a href="#Js实现元素拖拽" class="headerlink" title="Js实现元素拖拽"></a>Js实现元素拖拽</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很多时候，我们业务中需要对鼠标点击的元素进行拖拽，使用原生JS实现这个方法，主要用到鼠标事件和监听。</p><ol><li>onmousedown：鼠标按下事件</li><li>onmousemove：鼠标移动事件</li><li>onmouseup：鼠标抬起事件</li></ol><p>注意：</p><ol><li>被拖拽的元素一定要是绝对定位，脱离文档流才可以移动</li><li>绑定拖拽的元素，移动和鼠标松开后是对document的绑定，因为移动的是整个div。</li></ol><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><ol><li>先获取<strong>被拖拽元素</strong>所能移动的<strong>最大距离</strong>，超过这个距离就移动不了</li><li>给元素的onmousedown绑定一个function(e)事件</li><li>获取鼠标按下的原点<strong>距离盒子边缘的距离</strong>diffX和diffY</li><li>设置onmousemove事件，将被拖拽元素的left和top设置</li><li>left的值是<strong>拖拽之后的那个位置</strong>的鼠标的x值减去diffX</li><li>top的值是<strong>拖拽之后的那个位置</strong>的鼠标的y值减去diffY</li><li>设置鼠标松开事件onmouseup</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 禁止图片拖拽打开新页面 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://tvax4.sinaimg.cn/large/ec43126fgy1gzp7qtgjs0j213a1jlnpd.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">ondragstart</span>=<span class="string">&quot;return false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 一定要绝对定位 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">150px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.box</span> <span class="selector-tag">img</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 获取盒子元素</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 获取元素最大能移动到的距离</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> maxLeft = <span class="variable language_">window</span>.<span class="property">innerWidth</span> - box.<span class="property">offsetWidth</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> maxTop = <span class="variable language_">window</span>.<span class="property">innerHeight</span> - box.<span class="property">offsetHeight</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 鼠标按下盒子事件</span></span></span><br><span class="line"><span class="language-javascript">    box.<span class="property">onmousedown</span> = <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        e = e || <span class="variable language_">window</span>.<span class="property">event</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 获取鼠标按下的原点距离盒子边缘的距离</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> diffX = e.<span class="property">clientX</span> - box.<span class="property">offsetLeft</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> diffY = e.<span class="property">clientY</span> - box.<span class="property">offsetTop</span></span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 鼠标移动</span></span></span><br><span class="line"><span class="language-javascript">        box.<span class="property">onmousemove</span> = <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            e = e || <span class="variable language_">window</span>.<span class="property">event</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 移动之后记下鼠标在按下时的位置</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> x = e.<span class="property">clientX</span> - diffX</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> y = e.<span class="property">clientY</span> - diffY</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 限定元素只能在浏览器可视窗口内移动</span></span></span><br><span class="line"><span class="language-javascript">            x = x &lt; <span class="number">0</span> ? <span class="number">0</span> : x &gt; maxLeft ? maxLeft : x</span></span><br><span class="line"><span class="language-javascript">            y = y &lt; <span class="number">0</span> ? <span class="number">0</span> : y &gt; maxTop ? maxTop : y</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            box.<span class="property">style</span>.<span class="property">left</span> = x + <span class="string">&#x27;px&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">            box.<span class="property">style</span>.<span class="property">top</span> = y + <span class="string">&#x27;px&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        box.<span class="property">onmouseup</span> = <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">onmousemove</span> = <span class="literal">null</span> </span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">onmouseup</span> = <span class="literal">null</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h82bpvmwejg30ik0l2kjl.gif"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Js实现元素拖拽&quot;&gt;&lt;a href=&quot;#Js实现元素拖拽&quot; class=&quot;headerlink&quot; title=&quot;Js实现元素拖拽&quot;&gt;&lt;/a&gt;Js实现元素拖拽&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="前端" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="JavaScript" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
    <category term="前端" scheme="https://aliveseven.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="JavaScript" scheme="https://aliveseven.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Js实现防抖节流</title>
    <link href="https://aliveseven.github.io/posts/ffbd457d/"/>
    <id>https://aliveseven.github.io/posts/ffbd457d/</id>
    <published>2022-11-07T15:03:40.299Z</published>
    <updated>2022-11-08T17:13:30.703Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Js实现防抖节流"><a href="#Js实现防抖节流" class="headerlink" title="Js实现防抖节流"></a>Js实现防抖节流</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>防抖节流是经常在开发中用到的一个东西，都是用来控制某个函数在一定时间内触发次数，两者都是为了<strong>减少触发频率</strong>，以便提高性能或者说避免资源浪费。</p><p><strong>防抖：</strong> n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时</p><p><strong>节流：</strong> n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效</p><h2 id="手写防抖"><a href="#手写防抖" class="headerlink" title="手写防抖"></a>手写防抖</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;FangDou&quot;</span>&gt;</span>防抖<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#FangDou&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 手写防抖</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 防抖是函数在n秒内重复触发，则重新计时</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// func  要进行防抖的方法，delay是要防抖的时间</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, delay</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 声明变量来保存计时，让其作为局部变量保存在内存中，且不被随意访问，借助闭包来实现</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 返回一个闭包，通过return的函数可以来间接访问timer，</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 保存闭包被调用时的this</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// let that = this</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 如果时间期限还没到又触发了，则清除上一个定时器，重新计算时间</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span>(timer)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 清除定时器，debounce执行时要先把之前的setTimeout先清除再重新计时。</span></span></span><br><span class="line"><span class="language-javascript">                <span class="built_in">clearTimeout</span>(timer)</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 箭头函数的this永远指向外层作用域的this</span></span></span><br><span class="line"><span class="language-javascript">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 使用apply来改变this指向，apply函数会执行fn函数，并改变this指向</span></span></span><br><span class="line"><span class="language-javascript">        func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 执行完毕之后，再把timer设为null</span></span></span><br><span class="line"><span class="language-javascript">                    timer = <span class="literal">null</span></span></span><br><span class="line"><span class="language-javascript">        &#125;, delay)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">play</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">11111</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    btn.<span class="property">onclick</span> = <span class="title function_">debounce</span>(<span class="variable language_">this</span>.<span class="property">play</span> , <span class="number">500</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="手写节流"><a href="#手写节流" class="headerlink" title="手写节流"></a>手写节流</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手写节流</span></span><br><span class="line"><span class="comment">// 节流是函数在n秒内重复触发，只触发一次</span></span><br><span class="line"><span class="comment">// func  要进行节流的方法，delay是要节流的时间</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func , delay</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">// 每次触发事件时，如果当前有等待执行的函数，则直接return</span></span><br><span class="line">        <span class="keyword">if</span>(timer)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            func.<span class="title function_">apply</span>(<span class="variable language_">this</span> , <span class="variable language_">arguments</span>)</span><br><span class="line">            timer = <span class="literal">null</span></span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Js实现防抖节流&quot;&gt;&lt;a href=&quot;#Js实现防抖节流&quot; class=&quot;headerlink&quot; title=&quot;Js实现防抖节流&quot;&gt;&lt;/a&gt;Js实现防抖节流&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="前端" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="JavaScript" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
    <category term="前端" scheme="https://aliveseven.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="JavaScript" scheme="https://aliveseven.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Js实现图片懒加载</title>
    <link href="https://aliveseven.github.io/posts/388bfa10/"/>
    <id>https://aliveseven.github.io/posts/388bfa10/</id>
    <published>2022-11-04T16:25:34.145Z</published>
    <updated>2022-11-05T17:09:03.597Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Js实现图片懒加载"><a href="#Js实现图片懒加载" class="headerlink" title="Js实现图片懒加载"></a>Js实现图片懒加载</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>图片懒加载是一种对网页性能优化的方式，当访问一个页面的时候，优先加载可视区域的图片，而不是一次性把页面中的图片都请求加载出来。通过这种方式可以使页面加载速度变快，减轻服务器的压力，节省流量。</p><p>简单来说：就是不一次性加载那么多图片，而是慢慢来，按需加载。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><ol><li>首先获取当前元素距离顶部的距离</li><li>再获取屏幕的高度</li></ol><p>主要方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>，<span class="title class_">DOMobj</span>.<span class="title function_">getBoundingClientRect</span>().<span class="property">top</span>   <span class="comment">//获取该元素到屏幕顶部的距离</span></span><br><span class="line"><span class="number">2</span>，<span class="variable language_">window</span>.<span class="property">innerHeight</span>    <span class="comment">//屏幕的高度</span></span><br></pre></td></tr></table></figure><h2 id="简易版懒加载"><a href="#简易版懒加载" class="headerlink" title="简易版懒加载"></a>简易版懒加载</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;https://tvax2.sinaimg.cn/large/ec43126fgy1gnucibfc39j216f1kwn9p.jpg&quot;</span> <span class="attr">class</span>=<span class="string">&quot;lazy-load&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">src</span>=<span class="string">&quot;https://pic1.imgdb.cn/item/63344ce316f2c2beb1649065.gif&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;1&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;https://tva1.sinaimg.cn/large/ec43126fgy1gnl0376ljdj21e01utx6q.jpg&quot;</span> <span class="attr">class</span>=<span class="string">&quot;lazy-load&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">src</span>=<span class="string">&quot;https://pic1.imgdb.cn/item/63344ce316f2c2beb1649065.gif&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;2&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;https://tva3.sinaimg.cn/large/ec43126fgy1gyzyd4fabqj21h629ue81.jpg&quot;</span> <span class="attr">class</span>=<span class="string">&quot;lazy-load&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">src</span>=<span class="string">&quot;https://pic1.imgdb.cn/item/63344ce316f2c2beb1649065.gif&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;3&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;https://tva1.sinaimg.cn/large/ec43126fgy1gylpzp4ne6j213f1hl7wh.jpg&quot;</span> <span class="attr">class</span>=<span class="string">&quot;lazy-load&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">src</span>=<span class="string">&quot;https://pic1.imgdb.cn/item/63344ce316f2c2beb1649065.gif&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;4&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;https://tvax2.sinaimg.cn/large/ec43126fgy1gx5p5fkacuj21kr2bcb2c.jpg&quot;</span> <span class="attr">class</span>=<span class="string">&quot;lazy-load&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">src</span>=<span class="string">&quot;https://pic1.imgdb.cn/item/63344ce316f2c2beb1649065.gif&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;5&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;https://tva2.sinaimg.cn/large/ec43126fgy1h1y4bq4k6ej21xg19fqv5.jpg&quot;</span> <span class="attr">class</span>=<span class="string">&quot;lazy-load&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">src</span>=<span class="string">&quot;https://pic1.imgdb.cn/item/63344ce316f2c2beb1649065.gif&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;6&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;https://tvax2.sinaimg.cn/large/ec43126fgy1gza15dciynj21o02ooqv8.jpg&quot;</span> <span class="attr">class</span>=<span class="string">&quot;lazy-load&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">src</span>=<span class="string">&quot;https://pic1.imgdb.cn/item/63344ce316f2c2beb1649065.gif&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;7&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.box</span> <span class="selector-tag">img</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">imgLazyLoad</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 把类数组转换为真数组</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> imgs = [...<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.lazy-load&#x27;</span>)]</span></span><br><span class="line"><span class="language-javascript">        imgs.<span class="title function_">forEach</span>(<span class="function"><span class="params">img</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(img.<span class="title function_">getBoundingClientRect</span>().<span class="property">top</span> &lt; <span class="variable language_">window</span>.<span class="property">innerHeight</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 图片一旦有src就会加载出来，所以图片的路径不会放在src中，而是一个自定义的属性data-src中</span></span></span><br><span class="line"><span class="language-javascript">                img.<span class="property">src</span> = img.<span class="property">dataset</span>.<span class="property">src</span></span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 页面第一次加载，触发事件，屏幕内的图片正常加载，屏幕外的用scr内的代替</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">onload</span> = imgLazyLoad;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 监听滚轮事件</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>,imgLazyLoad)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h7uoupkqd7g31ca0o8hdt.gif"></p><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h7uoubkh8ag31ca0o8npf.gif"></p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>监听鼠标滚轮过于频繁，应该进行节流优化一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">imgLazyLoad</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">// 把类数组转换为真数组</span></span><br><span class="line">        <span class="keyword">var</span> imgs = [...<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.lazy-load&#x27;</span>)]</span><br><span class="line">        imgs.<span class="title function_">forEach</span>(<span class="function"><span class="params">img</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(img.<span class="title function_">getBoundingClientRect</span>().<span class="property">top</span> &lt; <span class="variable language_">window</span>.<span class="property">innerHeight</span>)&#123;</span><br><span class="line">                <span class="comment">// 图片一旦有src就会加载出来，所以图片的路径不会放在src中，而是一个自定义的属性data-src中</span></span><br><span class="line">                img.<span class="property">src</span> = img.<span class="property">dataset</span>.<span class="property">src</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 页面第一次加载，触发事件，屏幕内的图片正常加载，屏幕外的用scr内的代替</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">onload</span> = imgLazyLoad;</span><br><span class="line">    <span class="comment">// 监听滚轮事件</span></span><br><span class="line">    <span class="keyword">var</span> listenScroll = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 设置节流让其300ms只执行一次这个函数</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>,<span class="function">() =&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//在设定的时间内，则不执行函数</span></span><br><span class="line">        <span class="keyword">if</span>(!listenScroll)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 定时器事件</span></span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span>&#123;</span><br><span class="line">                <span class="title function_">imgLazyLoad</span>()</span><br><span class="line">                <span class="comment">// 事件执行完成之后，将监听事件的变量listenScroll变为true，即监听过了</span></span><br><span class="line">                listenScroll = <span class="literal">true</span></span><br><span class="line">            &#125;,<span class="number">300</span>);</span><br><span class="line">            <span class="comment">// 定时器执行完之后，再重新赋值监听事件的变量listenScroll</span></span><br><span class="line">            listenScroll = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="再优化"><a href="#再优化" class="headerlink" title="再优化"></a>再优化</h2><p>上面这种方式虽然也实现了懒加载，但是还是有一点缺点，就是一当发生滚动事件时，就发生了大量的循环和判断操作判断图片是否可视区里。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Js实现图片懒加载&quot;&gt;&lt;a href=&quot;#Js实现图片懒加载&quot; class=&quot;headerlink&quot; title=&quot;Js实现图片懒加载&quot;&gt;&lt;/a&gt;Js实现图片懒加载&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="前端" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="JavaScript" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
    <category term="前端" scheme="https://aliveseven.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="JavaScript" scheme="https://aliveseven.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>尝试手写Ajax</title>
    <link href="https://aliveseven.github.io/posts/1d0f8d42/"/>
    <id>https://aliveseven.github.io/posts/1d0f8d42/</id>
    <published>2022-11-03T12:47:09.345Z</published>
    <updated>2022-11-03T13:48:07.882Z</updated>
    
    <content type="html"><![CDATA[<h1 id="尝试手写Ajax"><a href="#尝试手写Ajax" class="headerlink" title="尝试手写Ajax"></a>尝试手写Ajax</h1><h2 id="Ajax是什么"><a href="#Ajax是什么" class="headerlink" title="Ajax是什么"></a>Ajax是什么</h2><p><code>AJAX</code> 即 <code>Asynchronous Javascript And XML</code>（异步JavaScript和XML），是指一种创建交互式网页应用的网页开发技术。可以通过Ajax向服务端发起异步请求数据，最大的优势在于无需刷新即可获取到数据。</p><h2 id="Ajax的优缺点"><a href="#Ajax的优缺点" class="headerlink" title="Ajax的优缺点"></a>Ajax的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>可以无需刷新页面而与服务器端进行通信</li><li>充分利用客户端闲置的处理能力，减轻服务器和网络传输的负担</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>Ajax干掉了Back和History功能，即对浏览器机制的破坏。</li><li>没有浏览历史，不能回退</li><li>存在跨域问题(同源)</li><li>SEO 不友好</li></ol><h2 id="发起请求的常见响应状态码"><a href="#发起请求的常见响应状态码" class="headerlink" title="发起请求的常见响应状态码"></a>发起请求的常见响应状态码</h2><ul><li>200 OK 请求成功。一般用于GET 与POST 请求</li><li>201 Created 已创建。成功请求并创建了新的资源</li><li>401 Unauthorized 未授权/请求要求用户的身份认证</li><li>404 Not Found 服务器无法根据客户端的请求找到资源</li><li>500 Internal Server Error 服务器内部错误，无法完成请求</li></ul><h2 id="常见请求类型"><a href="#常见请求类型" class="headerlink" title="常见请求类型"></a>常见请求类型</h2><ul><li>GET: 从服务器端读取数据（查）</li><li>POST: 向服务器端添加新数据 （增）</li><li>PUT: 更新服务器端已经数据 （改）</li><li>DELETE: 删除服务器端数据 （删）</li></ul><h2 id="Ajax实现过程"><a href="#Ajax实现过程" class="headerlink" title="Ajax实现过程"></a>Ajax实现过程</h2><ol><li>创建Ajax的核心对象XMLHttpRequest对象</li><li>创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息</li><li>在发起请求之前，通过setRequestHeader方法来为Ajax请求添加头信息</li><li>发送HTTP请求</li><li>获取异步调用返回的数据，XMLHttpRequest状态变化时会触发onreadystatechange事件，可以通过设置监听函数，来处理请求成功后的结果</li><li>使用JavaScript和DOM实现局部刷新</li></ol><h2 id="手写Ajax"><a href="#手写Ajax" class="headerlink" title="手写Ajax"></a>手写Ajax</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建对象 </span></span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"><span class="comment">// 2. 初始化 设置请求方法和url</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;https://www.baidu.com/&#x27;</span>,<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 3.设置请求头</span></span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>,<span class="string">&quot;*&quot;</span>);</span><br><span class="line"><span class="comment">// xhr.responseType = &quot;json&quot;;</span></span><br><span class="line"><span class="comment">// 4. 事件绑定 处理服务端返回的结果</span></span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// readyState 是 xhr 对象中的属性, 表示状态 0 1 2 3 4</span></span><br><span class="line">    <span class="comment">// 判断 (服务端返回了所有的结果</span></span><br><span class="line">    <span class="keyword">if</span>(xhr.<span class="property">readyState</span> === <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="comment">// 判断响应状态码 200 404 403 401 500</span></span><br><span class="line">        <span class="keyword">if</span>(xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>)&#123;</span><br><span class="line">        <span class="comment">// 处理结果 行 头 空行 体</span></span><br><span class="line">        <span class="comment">// 响应</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;状态码&#x27;</span>, xhr.<span class="property">status</span>); <span class="comment">// 状态码</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;状态字符串&#x27;</span>, xhr.<span class="property">statusText</span>); <span class="comment">// 状态字符串</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;所有响应头&#x27;</span>, xhr.<span class="title function_">getAllResponseHeaders</span>()); <span class="comment">// 所有响应头</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应体&#x27;</span>, xhr.<span class="property">response</span>); <span class="comment">// 响应体</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//设置 result 的文本</span></span><br><span class="line">        result.<span class="property">innerHTML</span>=xhr.<span class="property">response</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5. 发送</span></span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure><h2 id="加入Promise"><a href="#加入Promise" class="headerlink" title="加入Promise"></a>加入Promise</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">url</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">        xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>,url,<span class="literal">true</span>)</span><br><span class="line">        xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(xhr.<span class="property">readyState</span> === <span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(xhr.<span class="property">status</span> === <span class="number">200</span>)&#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(xhr.<span class="property">responseText</span>))</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;error&#x27;</span>))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.<span class="title function_">send</span>(<span class="literal">null</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> promise</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">&#x27;xxxx.com&#x27;</span></span><br><span class="line"><span class="title function_">ajax</span>(url).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="API总结"><a href="#API总结" class="headerlink" title="API总结"></a>API总结</h2><ul><li><code>XMLHttpRequest()</code>：创建 XHR 对象的构造函数</li><li><code>status</code>：响应状态码值，如 200、404</li><li><code>statusText</code>：响应状态文本，如 ’ok‘、‘not found’</li><li><code>readyState</code>：标识请求状态的只读属性 0-1-2-3-4</li><li><code>onreadystatechange</code>：绑定 readyState 改变的监听</li><li><code>responseType</code>：指定响应数据类型，如果是 ‘json’，得到响应后自动解析响应</li><li><code>response</code>：响应体数据，类型取决于 responseType 的指定</li><li><code>timeout</code>：指定请求超时时间，默认为 0 代表没有限制</li><li><code>ontimeout</code>：绑定超时的监听</li><li><code>onerror</code>：绑定请求网络错误的监听</li><li><code>open()</code>：初始化一个请求，参数为：(method, url[, async])</li><li><code>send(data)</code>：发送请求</li><li><code>abort()</code>：中断请求 （发出到返回之间）</li><li><code>getResponseHeader(name)</code>：获取指定名称的响应头值</li><li><code>getAllResponseHeaders()</code>：获取所有响应头组成的字符串</li><li><code>setRequestHeader(name, value)</code>：设置请求头</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;尝试手写Ajax&quot;&gt;&lt;a href=&quot;#尝试手写Ajax&quot; class=&quot;headerlink&quot; title=&quot;尝试手写Ajax&quot;&gt;&lt;/a&gt;尝试手写Ajax&lt;/h1&gt;&lt;h2 id=&quot;Ajax是什么&quot;&gt;&lt;a href=&quot;#Ajax是什么&quot; class=&quot;header</summary>
      
    
    
    
    <category term="前端" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="面试" scheme="https://aliveseven.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="前端" scheme="https://aliveseven.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="JavaScript" scheme="https://aliveseven.github.io/tags/JavaScript/"/>
    
    <category term="面试" scheme="https://aliveseven.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端面试2</title>
    <link href="https://aliveseven.github.io/posts/552aed2/"/>
    <id>https://aliveseven.github.io/posts/552aed2/</id>
    <published>2022-10-31T13:47:01.607Z</published>
    <updated>2022-11-02T02:12:51.313Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端面试2"><a href="#前端面试2" class="headerlink" title="前端面试2"></a>前端面试2</h1><h2 id="说说http状态码，说明状态码表示的信息"><a href="#说说http状态码，说明状态码表示的信息" class="headerlink" title="说说http状态码，说明状态码表示的信息"></a>说说http状态码，说明状态码表示的信息</h2><h3 id="2开头-成功类"><a href="#2开头-成功类" class="headerlink" title="2开头-成功类"></a><strong>2开头-成功类</strong></h3><ul><li>200 请求已成功，返回想要的东西</li><li>201 请求成功，服务器正在创建请求的资源</li><li>202 服务器收到请求了，但是未处理</li><li>203 服务器成功处理，但是返回的信息是另一个来源</li><li>204、205 服务器成功处理，但是没有返回内容</li><li>206 成功处理了部分get请求 </li></ul><h3 id="3开头-重定向类（要完成请求，需要进一步操作）"><a href="#3开头-重定向类（要完成请求，需要进一步操作）" class="headerlink" title="3开头- 重定向类（要完成请求，需要进一步操作）"></a><strong>3开头- 重定向类（要完成请求，需要进一步操作）</strong></h3><ul><li>300 针对请求，服务器可执行多种操作</li><li>301 请求的网页已永久移动到新位置。</li><li>302 访问网页时，被<strong>暂时性</strong>重定向到另一个url上。</li></ul><h3 id="4开头-请求错误"><a href="#4开头-请求错误" class="headerlink" title="4开头-请求错误"></a><strong>4开头-请求错误</strong></h3><ul><li>400 请求参数有误，请求无法被服务器理解</li><li>401 请求需要请求者验证(无权限–token)</li><li>403 服务器拒绝该请求 (权限不够遭拒绝)</li><li>404 找不到请求网页</li></ul><h3 id="5开头：服务器错误"><a href="#5开头：服务器错误" class="headerlink" title="5开头：服务器错误"></a><strong>5开头：服务器错误</strong></h3><ul><li>500 （服务器内部错误）服务器遇到错误，无法完成请求</li><li>502 （<strong>错误网关</strong>）服务器作为网关或代理，从上游服务器收到无效响应。</li><li>503 （<strong>服务不可用</strong>）服务器目前无法使用（由于超载或停机维护）</li><li>504 （<strong>网关超时</strong>）服务器作为网关或代理</li></ul><h2 id="vue2实现双向绑定的原理"><a href="#vue2实现双向绑定的原理" class="headerlink" title="vue2实现双向绑定的原理"></a>vue2实现双向绑定的原理</h2><p>通过数据劫持结合发布订阅模式的方式来实现，通过<code>Object.defineProperty()</code>来劫持各个属性的<code>setter</code>，<code>getter</code>，在数据变动时发布消息给订阅者，触发相应的监听回调来渲染视图。</p><p>Js简单实现一下双向绑定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个函数，用来把传入的数据变成响应式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defReactive</span>(<span class="params">data , keys , value</span>)&#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data , keys ,&#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;调用了get方法&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newValue</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(newValue === value) <span class="keyword">return</span> ;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;调用了set方法，执行更新操作&#x27;</span>)</span><br><span class="line">            value = newValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    <span class="attr">msg</span>:<span class="string">&#x27;2&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(data).<span class="title function_">forEach</span>(<span class="function"><span class="params">element</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 把data中的每一项变成响应式数据</span></span><br><span class="line">    <span class="keyword">let</span> value = data[element]</span><br><span class="line">    <span class="title function_">defReactive</span>(data , element, value  )</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="property">msg</span>);</span><br><span class="line">data.<span class="property">message</span> = <span class="string">&#x27;nihao&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;更新后的数据&#x27;</span>,data)</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h7ou1n5i9ij30nv0cv788.jpg"></p><h2 id="vue2可以对数组动态监听变化吗"><a href="#vue2可以对数组动态监听变化吗" class="headerlink" title="vue2可以对数组动态监听变化吗"></a>vue2可以对数组动态监听变化吗</h2><ol><li><p>调用数组的pop、push、shift、unshift、splice、sort、reverse等方法时是可以监听到数组的变化的</p></li><li><p>不能监听的情况</p><p>（1） 直接通过下标赋值 arr[i] = value</p><p>（2） 直接修改数组长度 arr.length = newLen</p></li></ol><h3 id="有什么方法可以实现监听数组变化"><a href="#有什么方法可以实现监听数组变化" class="headerlink" title="有什么方法可以实现监听数组变化"></a>有什么方法可以实现监听数组变化</h3><ul><li>给data赋予新数组，就是将数组地址改变，或者$set</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">set</span>(arr, index, newvalue)</span><br><span class="line">vm.$set(arr, index, newvalue)</span><br><span class="line">arr.<span class="title function_">splice</span>(index, <span class="number">1</span>, newvalue)</span><br></pre></td></tr></table></figure><h2 id="vue父子组件挂载和卸载的生命周期如何执行"><a href="#vue父子组件挂载和卸载的生命周期如何执行" class="headerlink" title="vue父子组件挂载和卸载的生命周期如何执行"></a>vue父子组件挂载和卸载的生命周期如何执行</h2><p>在正常开发，挂载周期的执行顺序为：</p><p>父beforeCreate =&gt; 父created =&gt; 父beforeMount =&gt; 子beforeCreate =&gt; 子created =&gt; 子beforeMount =&gt; 子mounted =&gt; 父mounted</p><p>在数据更新阶段执行顺序为：</p><p>父beforeUpdate =&gt; 子beforeUpdate =&gt; 子updated =&gt; 父updated</p><p>在组件销毁阶段执行顺序为：</p><p>父beforeDestroy -&gt; 子beforeDestroy -&gt; 子destroyed -&gt; 父destroyed</p><p>由此可见，其实所有周期规律就是：<strong>只要子组件被引入触发，所处不管任何周期都是父组件先开始执行，然后等到子组件执行完，父组件收尾。</strong></p><h2 id="vue中v-for如何实现对数组，对象，数字的遍历"><a href="#vue中v-for如何实现对数组，对象，数字的遍历" class="headerlink" title="vue中v-for如何实现对数组，对象，数字的遍历"></a>vue中v-for如何实现对数组，对象，数字的遍历</h2><p>数组：v-for = “(item,index) in/of arr”<br>对象：v-for = “(value,key,index) in obj”<br>数字：v-for = “(item,index) in 数字”，index从1开始</p><h2 id="JS数组常用遍历方法用法及其各项区别"><a href="#JS数组常用遍历方法用法及其各项区别" class="headerlink" title="JS数组常用遍历方法用法及其各项区别"></a>JS数组常用遍历方法用法及其各项区别</h2><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><ol><li>for循环不到数组的私有属性</li><li>可以使用return|break|continue终止|结束循环</li><li>for属于编程式写法</li></ol><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol><li>forEach循环不到数组的私有属性</li><li>return|break|continue不起作用</li><li>forEach属于声明式写法，不关心具体实现</li></ol><h3 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a>for in</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> arr)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>可以遍历到数组私有属性的值</li><li>key的类型是string型</li><li>可以使用return|break|continue终止|结束循环</li><li>循环顺序不一定按照数组索引值来循环</li></ol><h3 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a>for of</h3><ol><li>不可以遍历数组的私有属性的值</li><li>val的值就是arr项的值</li><li>可以使用return|break|continue终止|结束循环</li></ol><h3 id="filter-map"><a href="#filter-map" class="headerlink" title="filter,map"></a><strong>filter,map</strong></h3><p><img src="https://pic3.zhimg.com/v2-76362e926268904c55408275bad13dd2_r.jpg"></p><p><strong>filter</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">3</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">4</span>].<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">3</span>; <span class="comment">// 返回数组中大于3的数</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// (3) [9, 7, 4]</span></span><br></pre></td></tr></table></figure><p><strong>map</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> li = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">`&lt;li&gt;<span class="subst">$&#123;item&#125;</span>&lt;/li&gt;`</span></span><br><span class="line">   &#125;)</span><br><span class="line">   &lt;!--</span><br><span class="line">       <span class="number">1</span>、li的值为:[<span class="string">&#x27;&lt;li&gt;1&lt;/li&gt;&#x27;</span>,<span class="string">&#x27;&lt;li&gt;2&lt;/li&gt;&#x27;</span>,<span class="string">&#x27;&lt;li&gt;3&lt;/li&gt;&#x27;</span>]</span><br><span class="line">   --&gt;</span><br><span class="line">   <span class="keyword">var</span> liList = li.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);<span class="comment">//返回结果为：&#x27;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;li&gt;3&lt;/li&gt;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="transform、translate、transition、animation区别"><a href="#transform、translate、transition、animation区别" class="headerlink" title="transform、translate、transition、animation区别"></a>transform、translate、transition、animation区别</h2><ol><li>transform：描述了元素的静态样式，本身不会呈现动画效果，主要应用于元素的 2D 或者 3D转换，可以将元素 旋转、缩放、移动、倾斜等</li><li>translate：是2D转换的一种方法，<strong>是transform的一个属性值</strong>，主要控制目标元素的移动（2D、3D）</li><li>transition：CSS过渡属性，为一个元素在不同状态切换的时候定义不同的过渡效果。</li><li>animation：强调流程与控制，对元素的一个或多个属性的变化进行控制，可以有多个关键帧（animation 和@ keyframes结合使用）</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前端面试2&quot;&gt;&lt;a href=&quot;#前端面试2&quot; class=&quot;headerlink&quot; title=&quot;前端面试2&quot;&gt;&lt;/a&gt;前端面试2&lt;/h1&gt;&lt;h2 id=&quot;说说http状态码，说明状态码表示的信息&quot;&gt;&lt;a href=&quot;#说说http状态码，说明状态码表示的信息&quot;</summary>
      
    
    
    
    <category term="前端" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="面试" scheme="https://aliveseven.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="前端" scheme="https://aliveseven.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="CSS" scheme="https://aliveseven.github.io/tags/CSS/"/>
    
    <category term="Vue" scheme="https://aliveseven.github.io/tags/Vue/"/>
    
    <category term="JavaScript" scheme="https://aliveseven.github.io/tags/JavaScript/"/>
    
    <category term="面试" scheme="https://aliveseven.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>SQL关联表查询，多表查询</title>
    <link href="https://aliveseven.github.io/posts/7128cd70/"/>
    <id>https://aliveseven.github.io/posts/7128cd70/</id>
    <published>2022-10-29T13:41:02.175Z</published>
    <updated>2022-10-29T13:58:50.265Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL关联表查询，多表查询"><a href="#SQL关联表查询，多表查询" class="headerlink" title="SQL关联表查询，多表查询"></a>SQL关联表查询，多表查询</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在进行设计和开发的时候，很多时候需要用到表查询，多个表关联查询能够很大简化我们获取数据的业务，这里主要讲一下SQL的左连接、右连接、内连接（left join , right join , inner join）    </p><p>案例表：</p><ol><li>sys_role_menu</li></ol><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h7mgzvrqiyj30hy0avtci.jpg"></p><ol start="2"><li>sys_role</li></ol><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h7mh09l6r3j30ik07ndk1.jpg"></p><h2 id="LEFT-JOIN"><a href="#LEFT-JOIN" class="headerlink" title="LEFT JOIN"></a>LEFT JOIN</h2><ol><li>左连接，不考虑where条件下，left join 会把左表所有数据查询出来，on及其后面的条件仅仅会影响右表的数据(符合就显示,不符合全部为null)</li><li>左连接关注的是左边的主表数据，不应该把on后面的从表中的条件加到where后，这样会影响原有主表中的数据</li></ol><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p><strong>select * from A left join B on A.aid = B.bid</strong></p><p>意思是：</p><p><strong>首先取出A表中所有数据，然后再加上与A，B匹配的的数据</strong></p><p><strong>表A：</strong></p><table><thead><tr><th>aid</th><th>ax</th></tr></thead><tbody><tr><td>1</td><td>A1</td></tr><tr><td>2</td><td>A2</td></tr><tr><td>3</td><td>A3</td></tr></tbody></table><p><strong>表B：</strong></p><table><thead><tr><th>bid</th><th>bx</th></tr></thead><tbody><tr><td>1</td><td>B1</td></tr><tr><td>2</td><td>B2</td></tr><tr><td>4</td><td>B4</td></tr></tbody></table><p><strong>那么LEFT JOIN指：</strong></p><table><thead><tr><th>aid</th><th>ax</th><th>bid</th><th>bx</th></tr></thead><tbody><tr><td>1</td><td>A1</td><td>1</td><td>B1</td></tr><tr><td>2</td><td>A2</td><td>2</td><td>B2</td></tr><tr><td>3</td><td>A3</td><td></td><td></td></tr></tbody></table><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h7mhnqmsehj30f80dz76x.jpg"></p><h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h3><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h7mgrl7464j30wd0kx7e8.jpg"></p><h2 id="RIGHT-JOIN"><a href="#RIGHT-JOIN" class="headerlink" title="RIGHT JOIN"></a>RIGHT JOIN</h2><p>和左连接差不多，右连接就是关注右边表的数据，先把右边表的数据查询出来，on及其后面的条件仅仅会影响左表的数据(符合就显示,不符合全部为null)</p><p><strong>select * from A right join B on A.aid = B.bid</strong></p><p>这里右边表是B，先把B表中的全部数据取出来，然后再加上与A，B匹配的数据。如果没有匹配的就是空</p><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h7mhzqgb3nj30hn0epacq.jpg"></p><h3 id="案例2-1"><a href="#案例2-1" class="headerlink" title="案例2"></a>案例2</h3><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h7mi1w40jxj30oj0lcwmj.jpg"></p><h2 id="INNER-JOIN"><a href="#INNER-JOIN" class="headerlink" title="INNER JOIN"></a>INNER JOIN</h2><p>和左右连接不一样，INNER JOIN是取公共部分的，不匹配的部分就直接去掉，而不是空NULL了。</p><p>公共的部分就是ON后面的那个连接语句，比如案例中的aid和bid相同的那个部分就是公共的部分</p><p><strong>select * from A inner join B on A.aid = B.bid</strong></p><h3 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h3><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h7mi437tnij30bi0e1jtc.jpg" alt="image.png"></p><h3 id="案例2-2"><a href="#案例2-2" class="headerlink" title="案例2"></a>案例2</h3><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h7mi4naynmj30ko0i9ahd.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SQL关联表查询，多表查询&quot;&gt;&lt;a href=&quot;#SQL关联表查询，多表查询&quot; class=&quot;headerlink&quot; title=&quot;SQL关联表查询，多表查询&quot;&gt;&lt;/a&gt;SQL关联表查询，多表查询&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; cla</summary>
      
    
    
    
    <category term="后端" scheme="https://aliveseven.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="后端" scheme="https://aliveseven.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="MySQL" scheme="https://aliveseven.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Element-UI中获取表格当前行的操作</title>
    <link href="https://aliveseven.github.io/posts/872aa20/"/>
    <id>https://aliveseven.github.io/posts/872aa20/</id>
    <published>2022-10-26T15:07:40.045Z</published>
    <updated>2022-10-27T12:43:46.898Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Element-UI中获取表格当前行的操作"><a href="#Element-UI中获取表格当前行的操作" class="headerlink" title="Element-UI中获取表格当前行的操作"></a>Element-UI中获取表格当前行的操作</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很多时候我们需要用Element-UI中的表格表单来展示我们的数据，而很多时候我们需要对这些数据做增删改查啥的，所以需要获取每一行的数据，当前行的数据，然后才能对当前行的数据进行操作。</p><p>比如，我现在有下面这样的一个需求，那么如何实现呢，第一步当然要获取当前行的数据嘛。这里我总结了两种方法来获取这些数据。</p><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h7j2t51xx6j31h10ertfo.jpg"></p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>Vue中有一个叫插槽的东西，可以在button按钮外层 使用<code>template</code> 标签包裹 然后使用<code>slot-scope=&quot;scope&quot;</code>，或者<code>#default=scope</code>进行设置 在需要获取数据的地方使用<code>scope.row</code>得到需要操作行的所有字段信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-table :data=&quot;tableData&quot; :border=&quot;true&quot; &gt;</span><br><span class="line">    &lt;el-table-column prop=&quot;id&quot; label=&quot;角色ID&quot;/&gt;</span><br><span class="line">    &lt;el-table-column prop=&quot;name&quot; label=&quot;角色名称&quot;  /&gt;</span><br><span class="line">    &lt;el-table-column prop=&quot;description&quot; label=&quot;角色描述&quot;  /&gt;</span><br><span class="line">    &lt;el-table-column prop=&quot;flag&quot; label=&quot;唯一标识&quot;  /&gt;</span><br><span class="line">    &lt;el-table-column label=&quot;操作&quot; width=&quot;250&quot;&gt;</span><br><span class="line">        &lt;template #default=&quot;scope&quot;&gt;</span><br><span class="line">        &lt;!-- 通过插槽scope获取当前行的数据，scope.row.id表示获取当前行的角色id --&gt;</span><br><span class="line">            &lt;el-button size=&quot;small&quot; @click=&quot;getRoleMenuInfo(scope.row.id)&quot; type=&quot;info&quot; :icon=&quot;Menu&quot; plain&gt;菜单管理&lt;/el-button&gt;</span><br><span class="line">            &lt;el-button size=&quot;small&quot; @click=&quot;&quot; type=&quot;warning&quot; plain&gt;编辑&lt;/el-button&gt;</span><br><span class="line">            &lt;el-button size=&quot;small&quot; type=&quot;danger&quot; @click=&quot;&quot;&gt;删除&lt;/el-button&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line">    &lt;/el-table-column&gt;</span><br><span class="line">&lt;/el-table&gt;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h7j30g6ylaj30u00fkq8b.jpg"></p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>Element Table控件里面提供了一个@current-change方法，这个方法的意思是，你鼠标经过的行数变了，就会触发这个函数，也就是当前行改变了就会自动调用这个函数。</p><p>这个函数有两个参数，第一个是currentRow是指当前行，oldCurrentRow指变化前的那行</p><blockquote><p>注意：这个函数对上面的那种情况不太适用。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h7j320ac2qj312h0ca78z.jpg"></p><p>可以先声明一个响应式对象用来保存当前行的数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前行数据对象</span></span><br><span class="line"><span class="keyword">const</span> currentRow = <span class="title function_">ref</span>(&#123;&#125;)</span><br></pre></td></tr></table></figure><p>然后定义一个函数，当前行发生变化的时候自动触发</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">TableCurrentChange</span>(<span class="params">val : any</span>)&#123;</span><br><span class="line">  currentRow.<span class="property">value</span> = val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- @current-change=&quot;&quot;后面紧跟着当前行改变后要触发的函数 --&gt;</span><br><span class="line"> &lt;el-table :data=&quot;tableData&quot; @current-change=&quot;TableCurrentChange&quot; ref=&quot;singleTableRef&quot; style=&quot;width: 98%;margin-left: 10px;height: 67vh;&quot;&gt;</span><br><span class="line">   &lt;el-table-column prop=&quot;id&quot; label=&quot;ID&quot; width=&quot;100&quot; /&gt;</span><br><span class="line">   &lt;el-table-column prop=&quot;username&quot; label=&quot;用户名&quot; width=&quot;120&quot; /&gt;</span><br><span class="line">   &lt;el-table-column prop=&quot;nickname&quot; label=&quot;昵称&quot; width=&quot;120&quot; /&gt;</span><br><span class="line"> &lt;/el-table&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Element-UI中获取表格当前行的操作&quot;&gt;&lt;a href=&quot;#Element-UI中获取表格当前行的操作&quot; class=&quot;headerlink&quot; title=&quot;Element-UI中获取表格当前行的操作&quot;&gt;&lt;/a&gt;Element-UI中获取表格当前行的操作&lt;/</summary>
      
    
    
    
    <category term="前端" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/Vue/"/>
    
    
    <category term="前端" scheme="https://aliveseven.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://aliveseven.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>el-tree控件获取当前选中节点的方法</title>
    <link href="https://aliveseven.github.io/posts/eb414ced/"/>
    <id>https://aliveseven.github.io/posts/eb414ced/</id>
    <published>2022-10-25T17:39:51.082Z</published>
    <updated>2022-10-25T17:44:50.439Z</updated>
    
    <content type="html"><![CDATA[<h1 id="el-tree控件获取当前选中节点的方法"><a href="#el-tree控件获取当前选中节点的方法" class="headerlink" title="el-tree控件获取当前选中节点的方法"></a>el-tree控件获取当前选中节点的方法</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在开发菜单权限分配的时候，用到了Element-Plus里面的Tree树形控件来显示菜单，但是在提交确认的时候需要知道当前已选的菜单节点，所以引出了题中的问题</p><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>其实也很简单，Element里面有个check方法，这个方法有两个参数可以传入，而第二个参数就是我们要的，第二参数即树目前的选中状态对象，包含 checkedNodes、checkedKeys、halfCheckedNodes、halfCheckedKeys 四个属性</p><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h7i1vtatx8j318b0g97c1.jpg"></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入的菜单</span></span><br><span class="line"><span class="keyword">const</span> menuArray : <span class="built_in">any</span> = <span class="title function_">ref</span>([])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入半选中的菜单</span></span><br><span class="line"><span class="keyword">const</span> menuHalfArray : <span class="built_in">any</span> = <span class="title function_">ref</span>([])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击菜单管理多选框</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleNodeClick</span> = (<span class="params">nodeObj : <span class="built_in">any</span> , SelectedObj : <span class="built_in">any</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="title class_">SelectedObj</span>.<span class="property">checkedNodes</span>)&#123;</span><br><span class="line">    menuArray.<span class="property">value</span> = <span class="title class_">SelectedObj</span>.<span class="property">checkedNodes</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 半选中菜单赋值</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="title class_">SelectedObj</span>.<span class="property">halfCheckedNodes</span>)&#123;</span><br><span class="line">    menuHalfArray.<span class="property">value</span> = <span class="title class_">SelectedObj</span>.<span class="property">halfCheckedNodes</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>checkedNodes既是当前选中的节点，而半选中的节点也可以通过halfCheckedNodes来获取。就是这么简单</p><p>另外，可以给el-tree控件加入node-key 属性，以保证每个树节点都有作为唯一标识的属性。使用上面的checkedKeys和halfCheckedKeys 方法是需要设置这个属性的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">TreeChecked</span> (nodeObj, <span class="title class_">SelectedObj</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">SelectedObj</span>)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">SelectedObj</span>.<span class="property">checkedKeys</span>)   <span class="comment">// 这是选中的节点的key数组</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">SelectedObj</span>.<span class="property">checkedNodes</span>)  <span class="comment">// 这是选中的节点数组  </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;el-tree控件获取当前选中节点的方法&quot;&gt;&lt;a href=&quot;#el-tree控件获取当前选中节点的方法&quot; class=&quot;headerlink&quot; title=&quot;el-tree控件获取当前选中节点的方法&quot;&gt;&lt;/a&gt;el-tree控件获取当前选中节点的方法&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="前端" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/Vue/"/>
    
    
    <category term="前端" scheme="https://aliveseven.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://aliveseven.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Java中list的stream流详解</title>
    <link href="https://aliveseven.github.io/posts/55abbcd5/"/>
    <id>https://aliveseven.github.io/posts/55abbcd5/</id>
    <published>2022-10-23T13:37:55.255Z</published>
    <updated>2022-10-25T17:47:46.866Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java中list的stream流详解"><a href="#Java中list的stream流详解" class="headerlink" title="Java中list的stream流详解"></a>Java中list的stream流详解</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>Java8中提供了Stream对集合操作作出了极大的简化，学习了Stream之后，我们以后不用使用for循环就能对集合作出很好的操作</li><li>使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询，也可以使用 Stream API 来并行执行操作。简而言之，Stream API 提供了一种高效且易于使用的处理数据的方式。</li></ul><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ul><li>Java中的Stream的所有操作都是针对流的，所以，使用Stream必须要得到Stream对象</li><li>比如</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Stream&lt;String&gt; stream = list.stream(); <span class="comment">//获取一个顺序流</span></span><br><span class="line">Stream&lt;String&gt; parallelStream = list.parallelStream(); <span class="comment">//获取一个并行流</span></span><br></pre></td></tr></table></figure><h3 id="获取流的方法"><a href="#获取流的方法" class="headerlink" title="获取流的方法"></a>获取流的方法</h3><ol><li>根据List集合获取流</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建List集合</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;一号&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;二号&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;三号&quot;</span>);</span><br><span class="line">Stream&lt;String&gt; stream1 = list.stream();</span><br></pre></td></tr></table></figure><ol start="2"><li>根据Set集合获取流</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream2 = set.stream();</span><br></pre></td></tr></table></figure><ol start="3"><li>根据Map集合获取流</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Map集合</span></span><br><span class="line">Map&lt;Integer,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>,<span class="string">&quot;一号&quot;</span>);</span><br><span class="line">map.put(<span class="number">2</span>,<span class="string">&quot;二号&quot;</span>);</span><br><span class="line">map.put(<span class="number">3</span>,<span class="string">&quot;三号&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 根据Map集合的键获取流</span></span><br><span class="line">Set&lt;Integer&gt; map1 = map.keySet();</span><br><span class="line">Stream&lt;Integer&gt; stream3 = map1.stream();</span><br><span class="line"><span class="comment">// 根据Map集合的值获取流</span></span><br><span class="line">Collection&lt;String&gt; map2 = map.values();</span><br><span class="line">Stream&lt;String&gt; stream4 = map2.stream();</span><br><span class="line"><span class="comment">// 根据Map集合的键值对对象获取瑞</span></span><br><span class="line">Set&lt;Map.Entry&lt;Integer, String&gt;&gt; map3 = map.entrySet();</span><br><span class="line">Stream&lt;Map.Entry&lt;Integer, String&gt;&gt; stream5 = map3.stream();</span><br></pre></td></tr></table></figure><ol start="4"><li>根据数组获取流</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 根据数组获取流</span><br><span class="line">String[] arr = &#123;&quot;一号&quot;,&quot;二号&quot;,&quot;三号&quot;&#125;;</span><br><span class="line">Stream&lt;String&gt; stream6 = Stream.of(arr);</span><br></pre></td></tr></table></figure><h3 id="Stream流的常用方法"><a href="#Stream流的常用方法" class="headerlink" title="Stream流的常用方法"></a>Stream流的常用方法</h3><h4 id="collect-Collectors-toList"><a href="#collect-Collectors-toList" class="headerlink" title=".collect(Collectors.toList())"></a>.collect(Collectors.toList())</h4><ul><li>使用map操作可以遍历集合中的每个对象，并对其进行操作，map之后，用.collect(Collectors.toList())会得到操作后的集合</li><li>使用filter()函数之后也可以通过该方法得到集合。</li><li>Collectors.toList() 用来结束Stream流</li></ul><h4 id="stream-filter"><a href="#stream-filter" class="headerlink" title="stream().filter()"></a>stream().filter()</h4><p>stream().filter()一般适用于list集合，主要作用就是条件查询，从集合中查询想要的数据。<strong>filter里面的参数user是指集合里面的每一项</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;User&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//创建3个对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        u1.setAge(<span class="number">23</span>);</span><br><span class="line">        u1.setName(<span class="string">&quot;xiaoming&quot;</span>);</span><br><span class="line">        u1.setId(<span class="number">123456</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        u2.setAge(<span class="number">26</span>);</span><br><span class="line">        u2.setName(<span class="string">&quot;xiaofang&quot;</span>);</span><br><span class="line">        u2.setId(<span class="number">77777</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">u3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        u3.setAge(<span class="number">18</span>);</span><br><span class="line">        u3.setName(<span class="string">&quot;honghong&quot;</span>);</span><br><span class="line">        u3.setId(<span class="number">11111</span>);</span><br><span class="line">        <span class="comment">//添加对象到集合</span></span><br><span class="line">        list.add(u1);</span><br><span class="line">        list.add(u2);</span><br><span class="line">        list.add(u3);</span><br><span class="line">        <span class="comment">//条件筛选</span></span><br><span class="line">        compare(list);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">compare</span><span class="params">(List&lt;User&gt; list)</span> &#123;</span><br><span class="line">        <span class="comment">//在集合中查询用户名为xiaofang的集合</span></span><br><span class="line">        List&lt;User&gt; userList = list.stream().filter(user -&gt; <span class="string">&quot;xiaofang&quot;</span>           .equals(user.getName())).collect(Collectors.toList());</span><br><span class="line">        </span><br><span class="line">        System.out.println(list);</span><br><span class="line">        System.out.println(userList);</span><br><span class="line">        </span><br><span class="line">        List&lt;User&gt; userList1 = list.stream().filter(user -&gt; user.getAge() &gt; <span class="number">19</span> &amp;&amp; user.getAge() &lt; <span class="number">24</span>).collect(Collectors.toList());</span><br><span class="line">        System.out.println(userList1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>filter：筛选（里面输入的筛选的条件（ <strong>user -&gt; “xiaofang”.equals(user.getName())</strong> ）），这里的条件是查询uesr对象中name属性。</p><h4 id="stream-map"><a href="#stream-map" class="headerlink" title="stream().map()"></a>stream().map()</h4><ol><li>stream().map()提取List对象的某一列值。然后可以通过<strong>forEach</strong>方法对该对象进行循环输出</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static void printList(List&lt;User&gt; list) &#123;</span><br><span class="line">    List&lt;String&gt; userList = list.stream().map(User::getName).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    userList.forEach(u -&gt; System.out.println(u));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="stream-sorted"><a href="#stream-sorted" class="headerlink" title="stream().sorted()"></a>stream().sorted()</h4><ul><li>对list集合进行排序</li></ul><ol><li>对id进行升序排序</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printSortList</span><span class="params">(List&lt;User&gt; list)</span> &#123;</span><br><span class="line"><span class="comment">// 升序排序</span></span><br><span class="line">    List&lt;User&gt; userList = list.stream().sorted(Comparator.comparing(User::getId)).collect(Collectors.toList());</span><br><span class="line">    userList.forEach(u -&gt; System.out.println(u));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>对id进行降序排序</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printSortList</span><span class="params">(List&lt;User&gt; list)</span> &#123;</span><br><span class="line">    <span class="comment">// 降序排序</span></span><br><span class="line">    List&lt;User&gt; userList = list.stream().sorted(Comparator.comparing(User::getId).reversed()).collect(Collectors.toList());</span><br><span class="line">    userList.forEach( u - &gt;System.out.println(u));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="流的中间操作"><a href="#流的中间操作" class="headerlink" title="流的中间操作"></a><strong>流的中间操作</strong></h3><ul><li>筛选与切片<pre><code>filter：过滤流中的某些元素limit(n)：获取n个元素skip(n)：跳过n元素，配合limit(n)可实现分页distinct：通过流中元素的 hashCode() 和 equals() 去除重复元素</code></pre></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">6</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">14</span>);</span><br><span class="line"> </span><br><span class="line">Stream&lt;Integer&gt; newStream = stream.filter(s -&gt; s &gt; <span class="number">5</span>) <span class="comment">//6 6 7 9 8 10 12 14 14</span></span><br><span class="line">        .distinct() <span class="comment">//6 7 9 8 10 12 14</span></span><br><span class="line">        .skip(<span class="number">2</span>) <span class="comment">//9 8 10 12 14</span></span><br><span class="line">        .limit(<span class="number">2</span>); <span class="comment">//9 8</span></span><br><span class="line">newStream.forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="Stream对象转换为集合"><a href="#Stream对象转换为集合" class="headerlink" title="Stream对象转换为集合"></a>Stream对象转换为集合</h3><ul><li><p><strong>collect(Collectors.toList())</strong> </p></li><li><p><strong>collect(Collectors.toSet())</strong></p></li><li><p><strong>collect(Collectors.toMap())</strong></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java中list的stream流详解&quot;&gt;&lt;a href=&quot;#Java中list的stream流详解&quot; class=&quot;headerlink&quot; title=&quot;Java中list的stream流详解&quot;&gt;&lt;/a&gt;Java中list的stream流详解&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="后端" scheme="https://aliveseven.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Java" scheme="https://aliveseven.github.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
    <category term="Java" scheme="https://aliveseven.github.io/tags/Java/"/>
    
    <category term="后端" scheme="https://aliveseven.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
</feed>
