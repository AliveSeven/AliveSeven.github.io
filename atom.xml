<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AliveSeven&#39;s Blog</title>
  
  
  <link href="https://aliveseven.github.io/atom.xml" rel="self"/>
  
  <link href="https://aliveseven.github.io/"/>
  <updated>2022-11-23T18:37:46.704Z</updated>
  <id>https://aliveseven.github.io/</id>
  
  <author>
    <name>AliveSeven</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue中$nextTick的作用</title>
    <link href="https://aliveseven.github.io/posts/f4a37cd9/"/>
    <id>https://aliveseven.github.io/posts/f4a37cd9/</id>
    <published>2022-11-23T18:35:06.165Z</published>
    <updated>2022-11-23T18:37:46.704Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue中-nextTick的作用"><a href="#Vue中-nextTick的作用" class="headerlink" title="Vue中$nextTick的作用"></a>Vue中$nextTick的作用</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有些时候，我们在做了某些回调方法或者说是作了某些修改数据的操作之后，会发现数据在视图上没有立即更新，出现这种情况如何解决，就用到了$nextTick了。</p><p>作用：它可以在下次dom更新循环结束之后执行延迟回调，在修改数据之后立即使用该方法，就可以获取更新之后的dom。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>在 Vue 的文档中，说明了 Vue 是<strong>异步</strong>执行 dom 更新的。然后异步任务的执行机制，是等所有同步任务执行完之后，浏览器读取任务队列中的异步任务，开始执行。当任务队列中的任务执行完毕之后，算一轮事件循环，这个时候Vue才会进行dom视图更新。</p><blockquote><p>Vue 在修改数据后，视图不会立刻更新，而是等<strong>同一事件循环</strong>中的所有数据变化完成之后，再统一进行视图更新。</p></blockquote><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>在vue的生命周期 <code>created()</code> 钩子函数中进行 dom 操作，一定要放在 <code>$nextTick()</code> 函数中执行。在 <code>created()</code> 钩子函数执行的时候 DOM 其实并未进行任何渲染，而此时进行 DOM 操作无异于徒劳，所以此处一定要将 DOM 操作的代码放进 <code>nextTick()</code> 的回调函数中。</li><li>在数据变化后要执行某个操作，而这个操作需要使用随数据改变而改变的 DOM 结构的时候，这个操作都应该放进 Vue.nextTick()的回调函数中。</li><li>获取元素宽度，需要在 DOM 渲染完毕后执行</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Vue中-nextTick的作用&quot;&gt;&lt;a href=&quot;#Vue中-nextTick的作用&quot; class=&quot;headerlink&quot; title=&quot;Vue中$nextTick的作用&quot;&gt;&lt;/a&gt;Vue中$nextTick的作用&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="前端" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/Vue/"/>
    
    
    <category term="前端" scheme="https://aliveseven.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://aliveseven.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue中watch和computed的区别</title>
    <link href="https://aliveseven.github.io/posts/a6899595/"/>
    <id>https://aliveseven.github.io/posts/a6899595/</id>
    <published>2022-11-23T15:31:31.944Z</published>
    <updated>2022-11-23T18:38:18.558Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单链表反转"><a href="#单链表反转" class="headerlink" title="单链表反转"></a>单链表反转</h1><p>先声明一个新的节点pre = null，然后声明一个新的节点cur = head，把头节点赋值给它，然后声明一个中间节点temp = cur.next，也就是将下一个节点赋值给中间节点temp</p><p>然后，赋值完之后再对cur.next进行操作，领cur.next = pre，也就是将当前节点的下一个节点，就是当前传过来的节点，比如一开始不是传入头节点吗，那么这时就让头节点的下一个节点指向pre，也就是null，然后再对pre进行操作，领pre = cur，主要是为下一次的迭代做好铺路，再让cur = temp，就是将开头中间节点保存的那个节点赋值给cur。以上的这些操作一直循环执行，直到cur指向null</p><p>最后，这些操作完之后，此时pre就是最后的节点了，返回pre</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;单链表反转&quot;&gt;&lt;a href=&quot;#单链表反转&quot; class=&quot;headerlink&quot; title=&quot;单链表反转&quot;&gt;&lt;/a&gt;单链表反转&lt;/h1&gt;&lt;p&gt;先声明一个新的节点pre = null，然后声明一个新的节点cur = head，把头节点赋值给它，然后声明一个中间</summary>
      
    
    
    
    <category term="前端" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/Vue/"/>
    
    
    <category term="前端" scheme="https://aliveseven.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://aliveseven.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue3通过Vite动态引入图片:scr</title>
    <link href="https://aliveseven.github.io/posts/b0c5b807/"/>
    <id>https://aliveseven.github.io/posts/b0c5b807/</id>
    <published>2022-11-18T13:12:01.255Z</published>
    <updated>2022-11-18T14:32:29.016Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue3通过Vite动态引入图片-scr"><a href="#Vue3通过Vite动态引入图片-scr" class="headerlink" title="Vue3通过Vite动态引入图片:scr"></a>Vue3通过Vite动态引入图片:scr</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很多时候我们在开发的时候需要动态引入图片，在Vue2中可以用require()来实现这个，但是Vue3中却不支持require()。</p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><ul><li>给scr绑定一个函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img :src=&quot;getImageUrl(img)&quot; alt=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure><ul><li>获取照片的函数</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getImageUrl</span>(<span class="params">img : <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">`../assets/Img/<span class="subst">$&#123;img&#125;</span>.jpg`</span>, <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>).<span class="property">href</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="new-URL"><a href="#new-URL" class="headerlink" title="new URL()"></a>new URL()</h2><ul><li>用于创建一个新 URL 对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title function_">URL</span>(url, [base])</span><br></pre></td></tr></table></figure><ul><li>url —— 完整的 URL，或者仅路径（如果设置了 base）</li><li>base —— 可选的 base URL：如果设置了此参数，且参数 url 只有路径，则会根据这个 base 生成 URL。</li><li><code>import.meta.url</code>是base url（根链接）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Vue3通过Vite动态引入图片-scr&quot;&gt;&lt;a href=&quot;#Vue3通过Vite动态引入图片-scr&quot; class=&quot;headerlink&quot; title=&quot;Vue3通过Vite动态引入图片:scr&quot;&gt;&lt;/a&gt;Vue3通过Vite动态引入图片:scr&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="前端" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/Vue/"/>
    
    
    <category term="前端" scheme="https://aliveseven.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://aliveseven.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>事件循环机制</title>
    <link href="https://aliveseven.github.io/posts/6628f169/"/>
    <id>https://aliveseven.github.io/posts/6628f169/</id>
    <published>2022-11-14T16:43:23.931Z</published>
    <updated>2022-11-21T13:58:00.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事件循环机制"><a href="#事件循环机制" class="headerlink" title="事件循环机制"></a>事件循环机制</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JavaScript是一种单线程的，为了利用好资源和任务分配，JS将任务分为同步任务和异步任务，<strong>而事件循环就是规定了执行任务的顺序。</strong></p><h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><p>事件循环机制就是按照以下的顺序模式来循环执行JS中的任务事件</p><p>顺序如下：</p><ol><li>同步先执行</li><li>异步（微任务 &gt; dom渲染 &gt; 宏任务，然后又继续去找有没微任务）</li></ol><h2 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h2><ul><li>promise.then（new promise构造函数是同步）、async/await。</li><li>process.nextTick</li><li>Promise.catch</li><li>resove/reject</li><li>MutationObserver</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><blockquote><p>Promise是异步的，是指他的then()和catch()方法，<strong>Promise本身还是同步的</strong>，所以遇到Promise还是先执行的Promise同步代码。（同步优先）</p></blockquote><h2 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h2><ul><li>setTimeout</li><li>setInterval</li><li>setImmediate</li><li>ajax请求</li><li>dom事件</li><li>script块</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>先执行同步代码，</li><li>遇到异步宏任务则将异步宏任务放入宏任务队列中，</li><li>遇到异步微任务则将异步微任务放入微任务队列中，</li><li>当所有同步代码执行完毕后，再将异步微任务从【队列】中调入【主线程】执行，</li><li>微任务执行完毕后再将异步宏任务从【队列】中调入【主线程】执行，<br>一直循环直至所有任务执行完毕。</li></ol><p>同步（Promise）&gt;异步（微任务（process.nextTick ，Promises.then，Promise.catch ，resove/reject，MutationObserver) &gt; 宏任务（setTimeout，setInterval，setImmediate））</p><p>注意 <code>new Promise() </code>是同步方法，<code>resolve</code>才是异步方法。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.程序开头，主线程，先执行，输出&#x27;script start&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.执行函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 3.1 执行await函数async2，也就是promise.then()</span></span><br><span class="line">    <span class="comment">// 3.4 执行完第一个await函数之后，微任务队列中还有一个任务，暂时跳出async函数</span></span><br><span class="line">    <span class="comment">// 3.5 输出&#x27;async1 end&#x27;，保留async1函数的上下文，然后跳出async1函数</span></span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">async2</span>()</span><br><span class="line">    <span class="comment">// 5.拿回执行权，输出</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 3.2 开始执行任务，输出 &#x27;async2 end&#x27;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async2 end&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.3 promise.resolve().then()，先加入微任务队列中，等待下一轮事件循环执行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async2 end1&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.开始调用async函数</span></span><br><span class="line"><span class="title function_">async1</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有微任务执行完，开始执行宏任务</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 new Promise是同步的，先执行同步</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 4.1 输出 &#x27;promise&#x27;，执行完这轮同步操作，继续往下看，还有没有同步的</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise&#x27;</span>)</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">&#125;)  <span class="comment">// 4.1 出现promise.then()，加入微任务队列，那么队列中就有两个微任务，按照先进先出的原则来执行，这一轮循环会先执行3.3 中的微任务，但是还是先执行同步任务先</span></span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">&#125;) <span class="comment">// 4.4 执行完上一个then()之后又产生一个新的微任务，继续输出，当前微任务队列执行完毕。执行权回到async1</span></span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.3 有同步任务，先执行同步任务，输出 &#x27;script end&#x27; ，再执行异步</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h8d3bi1ka3j30kw08v3z7.jpg"></p><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h8d3ekd507j30aw0kkwfk.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;事件循环机制&quot;&gt;&lt;a href=&quot;#事件循环机制&quot; class=&quot;headerlink&quot; title=&quot;事件循环机制&quot;&gt;&lt;/a&gt;事件循环机制&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="前端" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="JavaScript" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
    <category term="前端" scheme="https://aliveseven.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="JavaScript" scheme="https://aliveseven.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>宏任务和微任务详解</title>
    <link href="https://aliveseven.github.io/posts/eb14c465/"/>
    <id>https://aliveseven.github.io/posts/eb14c465/</id>
    <published>2022-11-14T13:52:43.384Z</published>
    <updated>2022-11-20T17:52:16.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="宏任务和微任务详解"><a href="#宏任务和微任务详解" class="headerlink" title="宏任务和微任务详解"></a>宏任务和微任务详解</h1><h2 id="JavaScript的单线程和任务队列"><a href="#JavaScript的单线程和任务队列" class="headerlink" title="JavaScript的单线程和任务队列"></a>JavaScript的单线程和任务队列</h2><ol><li>Js的内部引擎是单线程的，但是浏览器它是多线程的，单线程一意味着所有任务需要排队，前一个任务结束，才会执行后一个任务。</li><li>如果前一个任务耗时很长，后一个任务就不得不一直等待。而且有些时候，有些任务会挂载于<strong>等待状态</strong>，这个时候其实可以先去运行别的任务，等上一个任务需要再启动的时候，再来运行它。</li><li>于是，为了解决这个问题，有了同步任务（synchronous）和异步任务（asynchronous）。</li><li><strong>同步任务</strong>指的是，在<strong>主线程</strong>上，排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务</li><li><strong>异步任务</strong>指的是，不进入<strong>主线程</strong>，而进入“任务队列”（task queue）的任务，只有“任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</li></ol><p>这里借用一张图，就很好解释了同步和异步任务的执行过程</p><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h850mrn783j30tr0oidm6.jpg"></p><h2 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h2><p>前面我们已经介绍了同步任务和异步任务的执行过程，为了协调这些任务有条不紊地在主线程上执行，页面进程引入了<strong>消息队列和事件循环机制</strong>。</p><p><strong>宏任务（task）</strong>：就是JS 内部（任务队列里）的任务，严格按照时间顺序压栈和执行。比如 script(整体代码)、 setTimeOut、setInverter、setImmediate 、 MessageChannel等。</p><p><strong>微任务（Microtask ）</strong>：微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、<strong>宏任务结束之前</strong>。比如process.nextTick、Promise.then()、async/await（实际就是Promise）、MutationObserver（HTML5新特性）</p><p>主要的执行顺序是：</p><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h850n8sa2hj30tp0o9dl8.jpg"></p><h2 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h2><ol><li>在执行栈中执行一个宏任务。</li><li>执行过程中遇到微任务，<strong>将微任务添加到微任务队列中</strong>。</li><li>当前宏任务执行完毕，<strong>立即执行微任务队列中的任务。</strong></li><li>当前微任务队列中的任务执行完毕，检查渲染，GUI线程接管渲染。</li><li>渲染完毕后，js线程接管，开启下一次事件循环，执行下一次宏任务（事件队列中取）。</li></ol><p>借用一下别人的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;---start---&#x27;);//第一轮主线程</span><br><span class="line"> </span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;setTimeout&#x27;);  // 将回调代码放入个宏任务队列，第二轮宏任务执行</span><br><span class="line">&#125;, 0);</span><br><span class="line"> </span><br><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  console.log(&#x27;---Promise第一轮微任务同步执行---&#x27;);//第一轮微任务同步执行</span><br><span class="line">  resolve()</span><br><span class="line">&#125;).then(()=&gt;&#123;</span><br><span class="line">  console.log(&#x27;Promise.then实例成功回调执行&#x27;); // 将回调代码放入微任务队列，第一轮宏任务执行完后立即执行</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">console.log(&#x27;---end---&#x27;);//第一轮主线程结束</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h84zxbure1j30ai050dgf.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;宏任务和微任务详解&quot;&gt;&lt;a href=&quot;#宏任务和微任务详解&quot; class=&quot;headerlink&quot; title=&quot;宏任务和微任务详解&quot;&gt;&lt;/a&gt;宏任务和微任务详解&lt;/h1&gt;&lt;h2 id=&quot;JavaScript的单线程和任务队列&quot;&gt;&lt;a href=&quot;#JavaSc</summary>
      
    
    
    
    <category term="前端" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="面试" scheme="https://aliveseven.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="前端" scheme="https://aliveseven.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="JavaScript" scheme="https://aliveseven.github.io/tags/JavaScript/"/>
    
    <category term="面试" scheme="https://aliveseven.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Js实现元素拖拽</title>
    <link href="https://aliveseven.github.io/posts/e2d042a0/"/>
    <id>https://aliveseven.github.io/posts/e2d042a0/</id>
    <published>2022-11-12T06:24:13.951Z</published>
    <updated>2022-11-12T06:26:16.819Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Js实现元素拖拽"><a href="#Js实现元素拖拽" class="headerlink" title="Js实现元素拖拽"></a>Js实现元素拖拽</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很多时候，我们业务中需要对鼠标点击的元素进行拖拽，使用原生JS实现这个方法，主要用到鼠标事件和监听。</p><ol><li>onmousedown：鼠标按下事件</li><li>onmousemove：鼠标移动事件</li><li>onmouseup：鼠标抬起事件</li></ol><p>注意：</p><ol><li>被拖拽的元素一定要是绝对定位，脱离文档流才可以移动</li><li>绑定拖拽的元素，移动和鼠标松开后是对document的绑定，因为移动的是整个div。</li></ol><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><ol><li>先获取<strong>被拖拽元素</strong>所能移动的<strong>最大距离</strong>，超过这个距离就移动不了</li><li>给元素的onmousedown绑定一个function(e)事件</li><li>获取鼠标按下的原点<strong>距离盒子边缘的距离</strong>diffX和diffY</li><li>设置onmousemove事件，将被拖拽元素的left和top设置</li><li>left的值是<strong>拖拽之后的那个位置</strong>的鼠标的x值减去diffX</li><li>top的值是<strong>拖拽之后的那个位置</strong>的鼠标的y值减去diffY</li><li>设置鼠标松开事件onmouseup</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 禁止图片拖拽打开新页面 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://tvax4.sinaimg.cn/large/ec43126fgy1gzp7qtgjs0j213a1jlnpd.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">ondragstart</span>=<span class="string">&quot;return false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 一定要绝对定位 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">150px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.box</span> <span class="selector-tag">img</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 获取盒子元素</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 获取元素最大能移动到的距离</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> maxLeft = <span class="variable language_">window</span>.<span class="property">innerWidth</span> - box.<span class="property">offsetWidth</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> maxTop = <span class="variable language_">window</span>.<span class="property">innerHeight</span> - box.<span class="property">offsetHeight</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 鼠标按下盒子事件</span></span></span><br><span class="line"><span class="language-javascript">    box.<span class="property">onmousedown</span> = <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        e = e || <span class="variable language_">window</span>.<span class="property">event</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 获取鼠标按下的原点距离盒子边缘的距离</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> diffX = e.<span class="property">clientX</span> - box.<span class="property">offsetLeft</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> diffY = e.<span class="property">clientY</span> - box.<span class="property">offsetTop</span></span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 鼠标移动</span></span></span><br><span class="line"><span class="language-javascript">        box.<span class="property">onmousemove</span> = <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            e = e || <span class="variable language_">window</span>.<span class="property">event</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 移动之后记下鼠标在按下时的位置</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> x = e.<span class="property">clientX</span> - diffX</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> y = e.<span class="property">clientY</span> - diffY</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 限定元素只能在浏览器可视窗口内移动</span></span></span><br><span class="line"><span class="language-javascript">            x = x &lt; <span class="number">0</span> ? <span class="number">0</span> : x &gt; maxLeft ? maxLeft : x</span></span><br><span class="line"><span class="language-javascript">            y = y &lt; <span class="number">0</span> ? <span class="number">0</span> : y &gt; maxTop ? maxTop : y</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            box.<span class="property">style</span>.<span class="property">left</span> = x + <span class="string">&#x27;px&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">            box.<span class="property">style</span>.<span class="property">top</span> = y + <span class="string">&#x27;px&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        box.<span class="property">onmouseup</span> = <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">onmousemove</span> = <span class="literal">null</span> </span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">onmouseup</span> = <span class="literal">null</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h82bpvmwejg30ik0l2kjl.gif"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Js实现元素拖拽&quot;&gt;&lt;a href=&quot;#Js实现元素拖拽&quot; class=&quot;headerlink&quot; title=&quot;Js实现元素拖拽&quot;&gt;&lt;/a&gt;Js实现元素拖拽&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="前端" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="JavaScript" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
    <category term="前端" scheme="https://aliveseven.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="JavaScript" scheme="https://aliveseven.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Js实现防抖节流</title>
    <link href="https://aliveseven.github.io/posts/ffbd457d/"/>
    <id>https://aliveseven.github.io/posts/ffbd457d/</id>
    <published>2022-11-07T15:03:40.299Z</published>
    <updated>2022-11-08T17:13:30.703Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Js实现防抖节流"><a href="#Js实现防抖节流" class="headerlink" title="Js实现防抖节流"></a>Js实现防抖节流</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>防抖节流是经常在开发中用到的一个东西，都是用来控制某个函数在一定时间内触发次数，两者都是为了<strong>减少触发频率</strong>，以便提高性能或者说避免资源浪费。</p><p><strong>防抖：</strong> n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时</p><p><strong>节流：</strong> n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效</p><h2 id="手写防抖"><a href="#手写防抖" class="headerlink" title="手写防抖"></a>手写防抖</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;FangDou&quot;</span>&gt;</span>防抖<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#FangDou&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 手写防抖</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 防抖是函数在n秒内重复触发，则重新计时</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// func  要进行防抖的方法，delay是要防抖的时间</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, delay</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 声明变量来保存计时，让其作为局部变量保存在内存中，且不被随意访问，借助闭包来实现</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 返回一个闭包，通过return的函数可以来间接访问timer，</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 保存闭包被调用时的this</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// let that = this</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 如果时间期限还没到又触发了，则清除上一个定时器，重新计算时间</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span>(timer)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 清除定时器，debounce执行时要先把之前的setTimeout先清除再重新计时。</span></span></span><br><span class="line"><span class="language-javascript">                <span class="built_in">clearTimeout</span>(timer)</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 箭头函数的this永远指向外层作用域的this</span></span></span><br><span class="line"><span class="language-javascript">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 使用apply来改变this指向，apply函数会执行fn函数，并改变this指向</span></span></span><br><span class="line"><span class="language-javascript">        func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 执行完毕之后，再把timer设为null</span></span></span><br><span class="line"><span class="language-javascript">                    timer = <span class="literal">null</span></span></span><br><span class="line"><span class="language-javascript">        &#125;, delay)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">play</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">11111</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    btn.<span class="property">onclick</span> = <span class="title function_">debounce</span>(<span class="variable language_">this</span>.<span class="property">play</span> , <span class="number">500</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="手写节流"><a href="#手写节流" class="headerlink" title="手写节流"></a>手写节流</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手写节流</span></span><br><span class="line"><span class="comment">// 节流是函数在n秒内重复触发，只触发一次</span></span><br><span class="line"><span class="comment">// func  要进行节流的方法，delay是要节流的时间</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func , delay</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">// 每次触发事件时，如果当前有等待执行的函数，则直接return</span></span><br><span class="line">        <span class="keyword">if</span>(timer)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            func.<span class="title function_">apply</span>(<span class="variable language_">this</span> , <span class="variable language_">arguments</span>)</span><br><span class="line">            timer = <span class="literal">null</span></span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Js实现防抖节流&quot;&gt;&lt;a href=&quot;#Js实现防抖节流&quot; class=&quot;headerlink&quot; title=&quot;Js实现防抖节流&quot;&gt;&lt;/a&gt;Js实现防抖节流&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="前端" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="JavaScript" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
    <category term="前端" scheme="https://aliveseven.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="JavaScript" scheme="https://aliveseven.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Js实现图片懒加载</title>
    <link href="https://aliveseven.github.io/posts/388bfa10/"/>
    <id>https://aliveseven.github.io/posts/388bfa10/</id>
    <published>2022-11-04T16:25:34.145Z</published>
    <updated>2022-11-05T17:09:03.597Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Js实现图片懒加载"><a href="#Js实现图片懒加载" class="headerlink" title="Js实现图片懒加载"></a>Js实现图片懒加载</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>图片懒加载是一种对网页性能优化的方式，当访问一个页面的时候，优先加载可视区域的图片，而不是一次性把页面中的图片都请求加载出来。通过这种方式可以使页面加载速度变快，减轻服务器的压力，节省流量。</p><p>简单来说：就是不一次性加载那么多图片，而是慢慢来，按需加载。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><ol><li>首先获取当前元素距离顶部的距离</li><li>再获取屏幕的高度</li></ol><p>主要方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>，<span class="title class_">DOMobj</span>.<span class="title function_">getBoundingClientRect</span>().<span class="property">top</span>   <span class="comment">//获取该元素到屏幕顶部的距离</span></span><br><span class="line"><span class="number">2</span>，<span class="variable language_">window</span>.<span class="property">innerHeight</span>    <span class="comment">//屏幕的高度</span></span><br></pre></td></tr></table></figure><h2 id="简易版懒加载"><a href="#简易版懒加载" class="headerlink" title="简易版懒加载"></a>简易版懒加载</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;https://tvax2.sinaimg.cn/large/ec43126fgy1gnucibfc39j216f1kwn9p.jpg&quot;</span> <span class="attr">class</span>=<span class="string">&quot;lazy-load&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">src</span>=<span class="string">&quot;https://pic1.imgdb.cn/item/63344ce316f2c2beb1649065.gif&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;1&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;https://tva1.sinaimg.cn/large/ec43126fgy1gnl0376ljdj21e01utx6q.jpg&quot;</span> <span class="attr">class</span>=<span class="string">&quot;lazy-load&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">src</span>=<span class="string">&quot;https://pic1.imgdb.cn/item/63344ce316f2c2beb1649065.gif&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;2&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;https://tva3.sinaimg.cn/large/ec43126fgy1gyzyd4fabqj21h629ue81.jpg&quot;</span> <span class="attr">class</span>=<span class="string">&quot;lazy-load&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">src</span>=<span class="string">&quot;https://pic1.imgdb.cn/item/63344ce316f2c2beb1649065.gif&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;3&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;https://tva1.sinaimg.cn/large/ec43126fgy1gylpzp4ne6j213f1hl7wh.jpg&quot;</span> <span class="attr">class</span>=<span class="string">&quot;lazy-load&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">src</span>=<span class="string">&quot;https://pic1.imgdb.cn/item/63344ce316f2c2beb1649065.gif&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;4&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;https://tvax2.sinaimg.cn/large/ec43126fgy1gx5p5fkacuj21kr2bcb2c.jpg&quot;</span> <span class="attr">class</span>=<span class="string">&quot;lazy-load&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">src</span>=<span class="string">&quot;https://pic1.imgdb.cn/item/63344ce316f2c2beb1649065.gif&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;5&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;https://tva2.sinaimg.cn/large/ec43126fgy1h1y4bq4k6ej21xg19fqv5.jpg&quot;</span> <span class="attr">class</span>=<span class="string">&quot;lazy-load&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">src</span>=<span class="string">&quot;https://pic1.imgdb.cn/item/63344ce316f2c2beb1649065.gif&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;6&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-src</span>=<span class="string">&quot;https://tvax2.sinaimg.cn/large/ec43126fgy1gza15dciynj21o02ooqv8.jpg&quot;</span> <span class="attr">class</span>=<span class="string">&quot;lazy-load&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">src</span>=<span class="string">&quot;https://pic1.imgdb.cn/item/63344ce316f2c2beb1649065.gif&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;7&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.box</span> <span class="selector-tag">img</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">imgLazyLoad</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 把类数组转换为真数组</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> imgs = [...<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.lazy-load&#x27;</span>)]</span></span><br><span class="line"><span class="language-javascript">        imgs.<span class="title function_">forEach</span>(<span class="function"><span class="params">img</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(img.<span class="title function_">getBoundingClientRect</span>().<span class="property">top</span> &lt; <span class="variable language_">window</span>.<span class="property">innerHeight</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 图片一旦有src就会加载出来，所以图片的路径不会放在src中，而是一个自定义的属性data-src中</span></span></span><br><span class="line"><span class="language-javascript">                img.<span class="property">src</span> = img.<span class="property">dataset</span>.<span class="property">src</span></span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 页面第一次加载，触发事件，屏幕内的图片正常加载，屏幕外的用scr内的代替</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">onload</span> = imgLazyLoad;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 监听滚轮事件</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>,imgLazyLoad)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h7uoupkqd7g31ca0o8hdt.gif" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h7uoubkh8ag31ca0o8npf.gif" alt=""></p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>监听鼠标滚轮过于频繁，应该进行节流优化一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">imgLazyLoad</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">// 把类数组转换为真数组</span></span><br><span class="line">        <span class="keyword">var</span> imgs = [...<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.lazy-load&#x27;</span>)]</span><br><span class="line">        imgs.<span class="title function_">forEach</span>(<span class="function"><span class="params">img</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(img.<span class="title function_">getBoundingClientRect</span>().<span class="property">top</span> &lt; <span class="variable language_">window</span>.<span class="property">innerHeight</span>)&#123;</span><br><span class="line">                <span class="comment">// 图片一旦有src就会加载出来，所以图片的路径不会放在src中，而是一个自定义的属性data-src中</span></span><br><span class="line">                img.<span class="property">src</span> = img.<span class="property">dataset</span>.<span class="property">src</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 页面第一次加载，触发事件，屏幕内的图片正常加载，屏幕外的用scr内的代替</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">onload</span> = imgLazyLoad;</span><br><span class="line">    <span class="comment">// 监听滚轮事件</span></span><br><span class="line">    <span class="keyword">var</span> listenScroll = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 设置节流让其300ms只执行一次这个函数</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>,<span class="function">() =&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//在设定的时间内，则不执行函数</span></span><br><span class="line">        <span class="keyword">if</span>(!listenScroll)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 定时器事件</span></span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span>&#123;</span><br><span class="line">                <span class="title function_">imgLazyLoad</span>()</span><br><span class="line">                <span class="comment">// 事件执行完成之后，将监听事件的变量listenScroll变为true，即监听过了</span></span><br><span class="line">                listenScroll = <span class="literal">true</span></span><br><span class="line">            &#125;,<span class="number">300</span>);</span><br><span class="line">            <span class="comment">// 定时器执行完之后，再重新赋值监听事件的变量listenScroll</span></span><br><span class="line">            listenScroll = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="再优化"><a href="#再优化" class="headerlink" title="再优化"></a>再优化</h2><p>上面这种方式虽然也实现了懒加载，但是还是有一点缺点，就是一当发生滚动事件时，就发生了大量的循环和判断操作判断图片是否可视区里。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Js实现图片懒加载&quot;&gt;&lt;a href=&quot;#Js实现图片懒加载&quot; class=&quot;headerlink&quot; title=&quot;Js实现图片懒加载&quot;&gt;&lt;/a&gt;Js实现图片懒加载&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="前端" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="JavaScript" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
    <category term="前端" scheme="https://aliveseven.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="JavaScript" scheme="https://aliveseven.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>尝试手写Ajax</title>
    <link href="https://aliveseven.github.io/posts/1d0f8d42/"/>
    <id>https://aliveseven.github.io/posts/1d0f8d42/</id>
    <published>2022-11-03T12:47:09.345Z</published>
    <updated>2022-11-03T13:48:07.882Z</updated>
    
    <content type="html"><![CDATA[<h1 id="尝试手写Ajax"><a href="#尝试手写Ajax" class="headerlink" title="尝试手写Ajax"></a>尝试手写Ajax</h1><h2 id="Ajax是什么"><a href="#Ajax是什么" class="headerlink" title="Ajax是什么"></a>Ajax是什么</h2><p><code>AJAX</code> 即 <code>Asynchronous Javascript And XML</code>（异步JavaScript和XML），是指一种创建交互式网页应用的网页开发技术。可以通过Ajax向服务端发起异步请求数据，最大的优势在于无需刷新即可获取到数据。</p><h2 id="Ajax的优缺点"><a href="#Ajax的优缺点" class="headerlink" title="Ajax的优缺点"></a>Ajax的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>可以无需刷新页面而与服务器端进行通信</li><li>充分利用客户端闲置的处理能力，减轻服务器和网络传输的负担</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>Ajax干掉了Back和History功能，即对浏览器机制的破坏。</li><li>没有浏览历史，不能回退</li><li>存在跨域问题(同源)</li><li>SEO 不友好</li></ol><h2 id="发起请求的常见响应状态码"><a href="#发起请求的常见响应状态码" class="headerlink" title="发起请求的常见响应状态码"></a>发起请求的常见响应状态码</h2><ul><li>200 OK 请求成功。一般用于GET 与POST 请求</li><li>201 Created 已创建。成功请求并创建了新的资源</li><li>401 Unauthorized 未授权/请求要求用户的身份认证</li><li>404 Not Found 服务器无法根据客户端的请求找到资源</li><li>500 Internal Server Error 服务器内部错误，无法完成请求</li></ul><h2 id="常见请求类型"><a href="#常见请求类型" class="headerlink" title="常见请求类型"></a>常见请求类型</h2><ul><li>GET: 从服务器端读取数据（查）</li><li>POST: 向服务器端添加新数据 （增）</li><li>PUT: 更新服务器端已经数据 （改）</li><li>DELETE: 删除服务器端数据 （删）</li></ul><h2 id="Ajax实现过程"><a href="#Ajax实现过程" class="headerlink" title="Ajax实现过程"></a>Ajax实现过程</h2><ol><li>创建Ajax的核心对象XMLHttpRequest对象</li><li>创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息</li><li>在发起请求之前，通过setRequestHeader方法来为Ajax请求添加头信息</li><li>发送HTTP请求</li><li>获取异步调用返回的数据，XMLHttpRequest状态变化时会触发onreadystatechange事件，可以通过设置监听函数，来处理请求成功后的结果</li><li>使用JavaScript和DOM实现局部刷新</li></ol><h2 id="手写Ajax"><a href="#手写Ajax" class="headerlink" title="手写Ajax"></a>手写Ajax</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建对象 </span></span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"><span class="comment">// 2. 初始化 设置请求方法和url</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;https://www.baidu.com/&#x27;</span>,<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 3.设置请求头</span></span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>,<span class="string">&quot;*&quot;</span>);</span><br><span class="line"><span class="comment">// xhr.responseType = &quot;json&quot;;</span></span><br><span class="line"><span class="comment">// 4. 事件绑定 处理服务端返回的结果</span></span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// readyState 是 xhr 对象中的属性, 表示状态 0 1 2 3 4</span></span><br><span class="line">    <span class="comment">// 判断 (服务端返回了所有的结果</span></span><br><span class="line">    <span class="keyword">if</span>(xhr.<span class="property">readyState</span> === <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="comment">// 判断响应状态码 200 404 403 401 500</span></span><br><span class="line">        <span class="keyword">if</span>(xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>)&#123;</span><br><span class="line">        <span class="comment">// 处理结果 行 头 空行 体</span></span><br><span class="line">        <span class="comment">// 响应</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;状态码&#x27;</span>, xhr.<span class="property">status</span>); <span class="comment">// 状态码</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;状态字符串&#x27;</span>, xhr.<span class="property">statusText</span>); <span class="comment">// 状态字符串</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;所有响应头&#x27;</span>, xhr.<span class="title function_">getAllResponseHeaders</span>()); <span class="comment">// 所有响应头</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应体&#x27;</span>, xhr.<span class="property">response</span>); <span class="comment">// 响应体</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//设置 result 的文本</span></span><br><span class="line">        result.<span class="property">innerHTML</span>=xhr.<span class="property">response</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5. 发送</span></span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure><h2 id="加入Promise"><a href="#加入Promise" class="headerlink" title="加入Promise"></a>加入Promise</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">url</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">        xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>,url,<span class="literal">true</span>)</span><br><span class="line">        xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(xhr.<span class="property">readyState</span> === <span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(xhr.<span class="property">status</span> === <span class="number">200</span>)&#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(xhr.<span class="property">responseText</span>))</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;error&#x27;</span>))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.<span class="title function_">send</span>(<span class="literal">null</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> promise</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">&#x27;xxxx.com&#x27;</span></span><br><span class="line"><span class="title function_">ajax</span>(url).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="API总结"><a href="#API总结" class="headerlink" title="API总结"></a>API总结</h2><ul><li><code>XMLHttpRequest()</code>：创建 XHR 对象的构造函数</li><li><code>status</code>：响应状态码值，如 200、404</li><li><code>statusText</code>：响应状态文本，如 ’ok‘、‘not found’</li><li><code>readyState</code>：标识请求状态的只读属性 0-1-2-3-4</li><li><code>onreadystatechange</code>：绑定 readyState 改变的监听</li><li><code>responseType</code>：指定响应数据类型，如果是 ‘json’，得到响应后自动解析响应</li><li><code>response</code>：响应体数据，类型取决于 responseType 的指定</li><li><code>timeout</code>：指定请求超时时间，默认为 0 代表没有限制</li><li><code>ontimeout</code>：绑定超时的监听</li><li><code>onerror</code>：绑定请求网络错误的监听</li><li><code>open()</code>：初始化一个请求，参数为：(method, url[, async])</li><li><code>send(data)</code>：发送请求</li><li><code>abort()</code>：中断请求 （发出到返回之间）</li><li><code>getResponseHeader(name)</code>：获取指定名称的响应头值</li><li><code>getAllResponseHeaders()</code>：获取所有响应头组成的字符串</li><li><code>setRequestHeader(name, value)</code>：设置请求头</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;尝试手写Ajax&quot;&gt;&lt;a href=&quot;#尝试手写Ajax&quot; class=&quot;headerlink&quot; title=&quot;尝试手写Ajax&quot;&gt;&lt;/a&gt;尝试手写Ajax&lt;/h1&gt;&lt;h2 id=&quot;Ajax是什么&quot;&gt;&lt;a href=&quot;#Ajax是什么&quot; class=&quot;header</summary>
      
    
    
    
    <category term="前端" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="面试" scheme="https://aliveseven.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="前端" scheme="https://aliveseven.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="JavaScript" scheme="https://aliveseven.github.io/tags/JavaScript/"/>
    
    <category term="面试" scheme="https://aliveseven.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端面试2</title>
    <link href="https://aliveseven.github.io/posts/552aed2/"/>
    <id>https://aliveseven.github.io/posts/552aed2/</id>
    <published>2022-10-31T13:47:01.607Z</published>
    <updated>2022-11-02T02:12:51.313Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端面试2"><a href="#前端面试2" class="headerlink" title="前端面试2"></a>前端面试2</h1><h2 id="说说http状态码，说明状态码表示的信息"><a href="#说说http状态码，说明状态码表示的信息" class="headerlink" title="说说http状态码，说明状态码表示的信息"></a>说说http状态码，说明状态码表示的信息</h2><h3 id="2开头-成功类"><a href="#2开头-成功类" class="headerlink" title="2开头-成功类"></a><strong>2开头-成功类</strong></h3><ul><li>200 请求已成功，返回想要的东西</li><li>201 请求成功，服务器正在创建请求的资源</li><li>202 服务器收到请求了，但是未处理</li><li>203 服务器成功处理，但是返回的信息是另一个来源</li><li>204、205 服务器成功处理，但是没有返回内容</li><li>206 成功处理了部分get请求 </li></ul><h3 id="3开头-重定向类（要完成请求，需要进一步操作）"><a href="#3开头-重定向类（要完成请求，需要进一步操作）" class="headerlink" title="3开头- 重定向类（要完成请求，需要进一步操作）"></a><strong>3开头- 重定向类（要完成请求，需要进一步操作）</strong></h3><ul><li>300 针对请求，服务器可执行多种操作</li><li>301 请求的网页已永久移动到新位置。</li><li>302 访问网页时，被<strong>暂时性</strong>重定向到另一个url上。</li></ul><h3 id="4开头-请求错误"><a href="#4开头-请求错误" class="headerlink" title="4开头-请求错误"></a><strong>4开头-请求错误</strong></h3><ul><li>400 请求参数有误，请求无法被服务器理解</li><li>401 请求需要请求者验证(无权限–token)</li><li>403 服务器拒绝该请求 (权限不够遭拒绝)</li><li>404 找不到请求网页</li></ul><h3 id="5开头：服务器错误"><a href="#5开头：服务器错误" class="headerlink" title="5开头：服务器错误"></a><strong>5开头：服务器错误</strong></h3><ul><li>500 （服务器内部错误）服务器遇到错误，无法完成请求</li><li>502 （<strong>错误网关</strong>）服务器作为网关或代理，从上游服务器收到无效响应。</li><li>503 （<strong>服务不可用</strong>）服务器目前无法使用（由于超载或停机维护）</li><li>504 （<strong>网关超时</strong>）服务器作为网关或代理</li></ul><h2 id="vue2实现双向绑定的原理"><a href="#vue2实现双向绑定的原理" class="headerlink" title="vue2实现双向绑定的原理"></a>vue2实现双向绑定的原理</h2><p>通过数据劫持结合发布订阅模式的方式来实现，通过<code>Object.defineProperty()</code>来劫持各个属性的<code>setter</code>，<code>getter</code>，在数据变动时发布消息给订阅者，触发相应的监听回调来渲染视图。</p><p>Js简单实现一下双向绑定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个函数，用来把传入的数据变成响应式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defReactive</span>(<span class="params">data , keys , value</span>)&#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data , keys ,&#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;调用了get方法&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newValue</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(newValue === value) <span class="keyword">return</span> ;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;调用了set方法，执行更新操作&#x27;</span>)</span><br><span class="line">            value = newValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    <span class="attr">msg</span>:<span class="string">&#x27;2&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(data).<span class="title function_">forEach</span>(<span class="function"><span class="params">element</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 把data中的每一项变成响应式数据</span></span><br><span class="line">    <span class="keyword">let</span> value = data[element]</span><br><span class="line">    <span class="title function_">defReactive</span>(data , element, value  )</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="property">msg</span>);</span><br><span class="line">data.<span class="property">message</span> = <span class="string">&#x27;nihao&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;更新后的数据&#x27;</span>,data)</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h7ou1n5i9ij30nv0cv788.jpg"></p><h2 id="vue2可以对数组动态监听变化吗"><a href="#vue2可以对数组动态监听变化吗" class="headerlink" title="vue2可以对数组动态监听变化吗"></a>vue2可以对数组动态监听变化吗</h2><ol><li><p>调用数组的pop、push、shift、unshift、splice、sort、reverse等方法时是可以监听到数组的变化的</p></li><li><p>不能监听的情况</p><p>（1） 直接通过下标赋值 arr[i] = value</p><p>（2） 直接修改数组长度 arr.length = newLen</p></li></ol><h3 id="有什么方法可以实现监听数组变化"><a href="#有什么方法可以实现监听数组变化" class="headerlink" title="有什么方法可以实现监听数组变化"></a>有什么方法可以实现监听数组变化</h3><ul><li>给data赋予新数组，就是将数组地址改变，或者$set</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">set</span>(arr, index, newvalue)</span><br><span class="line">vm.$set(arr, index, newvalue)</span><br><span class="line">arr.<span class="title function_">splice</span>(index, <span class="number">1</span>, newvalue)</span><br></pre></td></tr></table></figure><h2 id="vue父子组件挂载和卸载的生命周期如何执行"><a href="#vue父子组件挂载和卸载的生命周期如何执行" class="headerlink" title="vue父子组件挂载和卸载的生命周期如何执行"></a>vue父子组件挂载和卸载的生命周期如何执行</h2><p>在正常开发，挂载周期的执行顺序为：</p><p>父beforeCreate =&gt; 父created =&gt; 父beforeMount =&gt; 子beforeCreate =&gt; 子created =&gt; 子beforeMount =&gt; 子mounted =&gt; 父mounted</p><p>在数据更新阶段执行顺序为：</p><p>父beforeUpdate =&gt; 子beforeUpdate =&gt; 子updated =&gt; 父updated</p><p>在组件销毁阶段执行顺序为：</p><p>父beforeDestroy -&gt; 子beforeDestroy -&gt; 子destroyed -&gt; 父destroyed</p><p>由此可见，其实所有周期规律就是：<strong>只要子组件被引入触发，所处不管任何周期都是父组件先开始执行，然后等到子组件执行完，父组件收尾。</strong></p><h2 id="vue中v-for如何实现对数组，对象，数字的遍历"><a href="#vue中v-for如何实现对数组，对象，数字的遍历" class="headerlink" title="vue中v-for如何实现对数组，对象，数字的遍历"></a>vue中v-for如何实现对数组，对象，数字的遍历</h2><p>数组：v-for = “(item,index) in/of arr”<br>对象：v-for = “(value,key,index) in obj”<br>数字：v-for = “(item,index) in 数字”，index从1开始</p><h2 id="JS数组常用遍历方法用法及其各项区别"><a href="#JS数组常用遍历方法用法及其各项区别" class="headerlink" title="JS数组常用遍历方法用法及其各项区别"></a>JS数组常用遍历方法用法及其各项区别</h2><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><ol><li>for循环不到数组的私有属性</li><li>可以使用return|break|continue终止|结束循环</li><li>for属于编程式写法</li></ol><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol><li>forEach循环不到数组的私有属性</li><li>return|break|continue不起作用</li><li>forEach属于声明式写法，不关心具体实现</li></ol><h3 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a>for in</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> arr)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>可以遍历到数组私有属性的值</li><li>key的类型是string型</li><li>可以使用return|break|continue终止|结束循环</li><li>循环顺序不一定按照数组索引值来循环</li></ol><h3 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a>for of</h3><ol><li>不可以遍历数组的私有属性的值</li><li>val的值就是arr项的值</li><li>可以使用return|break|continue终止|结束循环</li></ol><h3 id="filter-map"><a href="#filter-map" class="headerlink" title="filter,map"></a><strong>filter,map</strong></h3><p><img src="https://pic3.zhimg.com/v2-76362e926268904c55408275bad13dd2_r.jpg"></p><p><strong>filter</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">3</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">4</span>].<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">3</span>; <span class="comment">// 返回数组中大于3的数</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// (3) [9, 7, 4]</span></span><br></pre></td></tr></table></figure><p><strong>map</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> li = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">`&lt;li&gt;<span class="subst">$&#123;item&#125;</span>&lt;/li&gt;`</span></span><br><span class="line">   &#125;)</span><br><span class="line">   &lt;!--</span><br><span class="line">       <span class="number">1</span>、li的值为:[<span class="string">&#x27;&lt;li&gt;1&lt;/li&gt;&#x27;</span>,<span class="string">&#x27;&lt;li&gt;2&lt;/li&gt;&#x27;</span>,<span class="string">&#x27;&lt;li&gt;3&lt;/li&gt;&#x27;</span>]</span><br><span class="line">   --&gt;</span><br><span class="line">   <span class="keyword">var</span> liList = li.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);<span class="comment">//返回结果为：&#x27;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;li&gt;3&lt;/li&gt;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="transform、translate、transition、animation区别"><a href="#transform、translate、transition、animation区别" class="headerlink" title="transform、translate、transition、animation区别"></a>transform、translate、transition、animation区别</h2><ol><li>transform：描述了元素的静态样式，本身不会呈现动画效果，主要应用于元素的 2D 或者 3D转换，可以将元素 旋转、缩放、移动、倾斜等</li><li>translate：是2D转换的一种方法，<strong>是transform的一个属性值</strong>，主要控制目标元素的移动（2D、3D）</li><li>transition：CSS过渡属性，为一个元素在不同状态切换的时候定义不同的过渡效果。</li><li>animation：强调流程与控制，对元素的一个或多个属性的变化进行控制，可以有多个关键帧（animation 和@ keyframes结合使用）</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前端面试2&quot;&gt;&lt;a href=&quot;#前端面试2&quot; class=&quot;headerlink&quot; title=&quot;前端面试2&quot;&gt;&lt;/a&gt;前端面试2&lt;/h1&gt;&lt;h2 id=&quot;说说http状态码，说明状态码表示的信息&quot;&gt;&lt;a href=&quot;#说说http状态码，说明状态码表示的信息&quot;</summary>
      
    
    
    
    <category term="前端" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="面试" scheme="https://aliveseven.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="前端" scheme="https://aliveseven.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://aliveseven.github.io/tags/Vue/"/>
    
    <category term="CSS" scheme="https://aliveseven.github.io/tags/CSS/"/>
    
    <category term="JavaScript" scheme="https://aliveseven.github.io/tags/JavaScript/"/>
    
    <category term="面试" scheme="https://aliveseven.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>SQL关联表查询，多表查询</title>
    <link href="https://aliveseven.github.io/posts/7128cd70/"/>
    <id>https://aliveseven.github.io/posts/7128cd70/</id>
    <published>2022-10-29T13:41:02.175Z</published>
    <updated>2022-10-29T13:58:50.265Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL关联表查询，多表查询"><a href="#SQL关联表查询，多表查询" class="headerlink" title="SQL关联表查询，多表查询"></a>SQL关联表查询，多表查询</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在进行设计和开发的时候，很多时候需要用到表查询，多个表关联查询能够很大简化我们获取数据的业务，这里主要讲一下SQL的左连接、右连接、内连接（left join , right join , inner join）    </p><p>案例表：</p><ol><li>sys_role_menu</li></ol><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h7mgzvrqiyj30hy0avtci.jpg"></p><ol start="2"><li>sys_role</li></ol><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h7mh09l6r3j30ik07ndk1.jpg"></p><h2 id="LEFT-JOIN"><a href="#LEFT-JOIN" class="headerlink" title="LEFT JOIN"></a>LEFT JOIN</h2><ol><li>左连接，不考虑where条件下，left join 会把左表所有数据查询出来，on及其后面的条件仅仅会影响右表的数据(符合就显示,不符合全部为null)</li><li>左连接关注的是左边的主表数据，不应该把on后面的从表中的条件加到where后，这样会影响原有主表中的数据</li></ol><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p><strong>select * from A left join B on A.aid = B.bid</strong></p><p>意思是：</p><p><strong>首先取出A表中所有数据，然后再加上与A，B匹配的的数据</strong></p><p><strong>表A：</strong></p><table><thead><tr><th>aid</th><th>ax</th></tr></thead><tbody><tr><td>1</td><td>A1</td></tr><tr><td>2</td><td>A2</td></tr><tr><td>3</td><td>A3</td></tr></tbody></table><p><strong>表B：</strong></p><table><thead><tr><th>bid</th><th>bx</th></tr></thead><tbody><tr><td>1</td><td>B1</td></tr><tr><td>2</td><td>B2</td></tr><tr><td>4</td><td>B4</td></tr></tbody></table><p><strong>那么LEFT JOIN指：</strong></p><table><thead><tr><th>aid</th><th>ax</th><th>bid</th><th>bx</th></tr></thead><tbody><tr><td>1</td><td>A1</td><td>1</td><td>B1</td></tr><tr><td>2</td><td>A2</td><td>2</td><td>B2</td></tr><tr><td>3</td><td>A3</td><td></td><td></td></tr></tbody></table><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h7mhnqmsehj30f80dz76x.jpg"></p><h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h3><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h7mgrl7464j30wd0kx7e8.jpg"></p><h2 id="RIGHT-JOIN"><a href="#RIGHT-JOIN" class="headerlink" title="RIGHT JOIN"></a>RIGHT JOIN</h2><p>和左连接差不多，右连接就是关注右边表的数据，先把右边表的数据查询出来，on及其后面的条件仅仅会影响左表的数据(符合就显示,不符合全部为null)</p><p><strong>select * from A right join B on A.aid = B.bid</strong></p><p>这里右边表是B，先把B表中的全部数据取出来，然后再加上与A，B匹配的数据。如果没有匹配的就是空</p><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h7mhzqgb3nj30hn0epacq.jpg"></p><h3 id="案例2-1"><a href="#案例2-1" class="headerlink" title="案例2"></a>案例2</h3><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h7mi1w40jxj30oj0lcwmj.jpg"></p><h2 id="INNER-JOIN"><a href="#INNER-JOIN" class="headerlink" title="INNER JOIN"></a>INNER JOIN</h2><p>和左右连接不一样，INNER JOIN是取公共部分的，不匹配的部分就直接去掉，而不是空NULL了。</p><p>公共的部分就是ON后面的那个连接语句，比如案例中的aid和bid相同的那个部分就是公共的部分</p><p><strong>select * from A inner join B on A.aid = B.bid</strong></p><h3 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h3><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h7mi437tnij30bi0e1jtc.jpg" alt="image.png"></p><h3 id="案例2-2"><a href="#案例2-2" class="headerlink" title="案例2"></a>案例2</h3><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h7mi4naynmj30ko0i9ahd.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SQL关联表查询，多表查询&quot;&gt;&lt;a href=&quot;#SQL关联表查询，多表查询&quot; class=&quot;headerlink&quot; title=&quot;SQL关联表查询，多表查询&quot;&gt;&lt;/a&gt;SQL关联表查询，多表查询&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; cla</summary>
      
    
    
    
    <category term="后端" scheme="https://aliveseven.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="后端" scheme="https://aliveseven.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="MySQL" scheme="https://aliveseven.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Element-UI中获取表格当前行的操作</title>
    <link href="https://aliveseven.github.io/posts/872aa20/"/>
    <id>https://aliveseven.github.io/posts/872aa20/</id>
    <published>2022-10-26T15:07:40.045Z</published>
    <updated>2022-10-27T12:43:46.898Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Element-UI中获取表格当前行的操作"><a href="#Element-UI中获取表格当前行的操作" class="headerlink" title="Element-UI中获取表格当前行的操作"></a>Element-UI中获取表格当前行的操作</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很多时候我们需要用Element-UI中的表格表单来展示我们的数据，而很多时候我们需要对这些数据做增删改查啥的，所以需要获取每一行的数据，当前行的数据，然后才能对当前行的数据进行操作。</p><p>比如，我现在有下面这样的一个需求，那么如何实现呢，第一步当然要获取当前行的数据嘛。这里我总结了两种方法来获取这些数据。</p><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h7j2t51xx6j31h10ertfo.jpg"></p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>Vue中有一个叫插槽的东西，可以在button按钮外层 使用<code>template</code> 标签包裹 然后使用<code>slot-scope=&quot;scope&quot;</code>，或者<code>#default=scope</code>进行设置 在需要获取数据的地方使用<code>scope.row</code>得到需要操作行的所有字段信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-table :data=&quot;tableData&quot; :border=&quot;true&quot; &gt;</span><br><span class="line">    &lt;el-table-column prop=&quot;id&quot; label=&quot;角色ID&quot;/&gt;</span><br><span class="line">    &lt;el-table-column prop=&quot;name&quot; label=&quot;角色名称&quot;  /&gt;</span><br><span class="line">    &lt;el-table-column prop=&quot;description&quot; label=&quot;角色描述&quot;  /&gt;</span><br><span class="line">    &lt;el-table-column prop=&quot;flag&quot; label=&quot;唯一标识&quot;  /&gt;</span><br><span class="line">    &lt;el-table-column label=&quot;操作&quot; width=&quot;250&quot;&gt;</span><br><span class="line">        &lt;template #default=&quot;scope&quot;&gt;</span><br><span class="line">        &lt;!-- 通过插槽scope获取当前行的数据，scope.row.id表示获取当前行的角色id --&gt;</span><br><span class="line">            &lt;el-button size=&quot;small&quot; @click=&quot;getRoleMenuInfo(scope.row.id)&quot; type=&quot;info&quot; :icon=&quot;Menu&quot; plain&gt;菜单管理&lt;/el-button&gt;</span><br><span class="line">            &lt;el-button size=&quot;small&quot; @click=&quot;&quot; type=&quot;warning&quot; plain&gt;编辑&lt;/el-button&gt;</span><br><span class="line">            &lt;el-button size=&quot;small&quot; type=&quot;danger&quot; @click=&quot;&quot;&gt;删除&lt;/el-button&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line">    &lt;/el-table-column&gt;</span><br><span class="line">&lt;/el-table&gt;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h7j30g6ylaj30u00fkq8b.jpg"></p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>Element Table控件里面提供了一个@current-change方法，这个方法的意思是，你鼠标经过的行数变了，就会触发这个函数，也就是当前行改变了就会自动调用这个函数。</p><p>这个函数有两个参数，第一个是currentRow是指当前行，oldCurrentRow指变化前的那行</p><blockquote><p>注意：这个函数对上面的那种情况不太适用。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h7j320ac2qj312h0ca78z.jpg"></p><p>可以先声明一个响应式对象用来保存当前行的数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前行数据对象</span></span><br><span class="line"><span class="keyword">const</span> currentRow = <span class="title function_">ref</span>(&#123;&#125;)</span><br></pre></td></tr></table></figure><p>然后定义一个函数，当前行发生变化的时候自动触发</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">TableCurrentChange</span>(<span class="params">val : any</span>)&#123;</span><br><span class="line">  currentRow.<span class="property">value</span> = val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- @current-change=&quot;&quot;后面紧跟着当前行改变后要触发的函数 --&gt;</span><br><span class="line"> &lt;el-table :data=&quot;tableData&quot; @current-change=&quot;TableCurrentChange&quot; ref=&quot;singleTableRef&quot; style=&quot;width: 98%;margin-left: 10px;height: 67vh;&quot;&gt;</span><br><span class="line">   &lt;el-table-column prop=&quot;id&quot; label=&quot;ID&quot; width=&quot;100&quot; /&gt;</span><br><span class="line">   &lt;el-table-column prop=&quot;username&quot; label=&quot;用户名&quot; width=&quot;120&quot; /&gt;</span><br><span class="line">   &lt;el-table-column prop=&quot;nickname&quot; label=&quot;昵称&quot; width=&quot;120&quot; /&gt;</span><br><span class="line"> &lt;/el-table&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Element-UI中获取表格当前行的操作&quot;&gt;&lt;a href=&quot;#Element-UI中获取表格当前行的操作&quot; class=&quot;headerlink&quot; title=&quot;Element-UI中获取表格当前行的操作&quot;&gt;&lt;/a&gt;Element-UI中获取表格当前行的操作&lt;/</summary>
      
    
    
    
    <category term="前端" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/Vue/"/>
    
    
    <category term="前端" scheme="https://aliveseven.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://aliveseven.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>el-tree控件获取当前选中节点的方法</title>
    <link href="https://aliveseven.github.io/posts/eb414ced/"/>
    <id>https://aliveseven.github.io/posts/eb414ced/</id>
    <published>2022-10-25T17:39:51.082Z</published>
    <updated>2022-10-25T17:44:50.439Z</updated>
    
    <content type="html"><![CDATA[<h1 id="el-tree控件获取当前选中节点的方法"><a href="#el-tree控件获取当前选中节点的方法" class="headerlink" title="el-tree控件获取当前选中节点的方法"></a>el-tree控件获取当前选中节点的方法</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在开发菜单权限分配的时候，用到了Element-Plus里面的Tree树形控件来显示菜单，但是在提交确认的时候需要知道当前已选的菜单节点，所以引出了题中的问题</p><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>其实也很简单，Element里面有个check方法，这个方法有两个参数可以传入，而第二个参数就是我们要的，第二参数即树目前的选中状态对象，包含 checkedNodes、checkedKeys、halfCheckedNodes、halfCheckedKeys 四个属性</p><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h7i1vtatx8j318b0g97c1.jpg"></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入的菜单</span></span><br><span class="line"><span class="keyword">const</span> menuArray : <span class="built_in">any</span> = <span class="title function_">ref</span>([])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入半选中的菜单</span></span><br><span class="line"><span class="keyword">const</span> menuHalfArray : <span class="built_in">any</span> = <span class="title function_">ref</span>([])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击菜单管理多选框</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleNodeClick</span> = (<span class="params">nodeObj : <span class="built_in">any</span> , SelectedObj : <span class="built_in">any</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="title class_">SelectedObj</span>.<span class="property">checkedNodes</span>)&#123;</span><br><span class="line">    menuArray.<span class="property">value</span> = <span class="title class_">SelectedObj</span>.<span class="property">checkedNodes</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 半选中菜单赋值</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="title class_">SelectedObj</span>.<span class="property">halfCheckedNodes</span>)&#123;</span><br><span class="line">    menuHalfArray.<span class="property">value</span> = <span class="title class_">SelectedObj</span>.<span class="property">halfCheckedNodes</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>checkedNodes既是当前选中的节点，而半选中的节点也可以通过halfCheckedNodes来获取。就是这么简单</p><p>另外，可以给el-tree控件加入node-key 属性，以保证每个树节点都有作为唯一标识的属性。使用上面的checkedKeys和halfCheckedKeys 方法是需要设置这个属性的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">TreeChecked</span> (nodeObj, <span class="title class_">SelectedObj</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">SelectedObj</span>)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">SelectedObj</span>.<span class="property">checkedKeys</span>)   <span class="comment">// 这是选中的节点的key数组</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">SelectedObj</span>.<span class="property">checkedNodes</span>)  <span class="comment">// 这是选中的节点数组  </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;el-tree控件获取当前选中节点的方法&quot;&gt;&lt;a href=&quot;#el-tree控件获取当前选中节点的方法&quot; class=&quot;headerlink&quot; title=&quot;el-tree控件获取当前选中节点的方法&quot;&gt;&lt;/a&gt;el-tree控件获取当前选中节点的方法&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="前端" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/Vue/"/>
    
    
    <category term="前端" scheme="https://aliveseven.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://aliveseven.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Java中list的stream流详解</title>
    <link href="https://aliveseven.github.io/posts/55abbcd5/"/>
    <id>https://aliveseven.github.io/posts/55abbcd5/</id>
    <published>2022-10-23T13:37:55.255Z</published>
    <updated>2022-10-25T17:47:46.866Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java中list的stream流详解"><a href="#Java中list的stream流详解" class="headerlink" title="Java中list的stream流详解"></a>Java中list的stream流详解</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>Java8中提供了Stream对集合操作作出了极大的简化，学习了Stream之后，我们以后不用使用for循环就能对集合作出很好的操作</li><li>使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询，也可以使用 Stream API 来并行执行操作。简而言之，Stream API 提供了一种高效且易于使用的处理数据的方式。</li></ul><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ul><li>Java中的Stream的所有操作都是针对流的，所以，使用Stream必须要得到Stream对象</li><li>比如</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Stream&lt;String&gt; stream = list.stream(); <span class="comment">//获取一个顺序流</span></span><br><span class="line">Stream&lt;String&gt; parallelStream = list.parallelStream(); <span class="comment">//获取一个并行流</span></span><br></pre></td></tr></table></figure><h3 id="获取流的方法"><a href="#获取流的方法" class="headerlink" title="获取流的方法"></a>获取流的方法</h3><ol><li>根据List集合获取流</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建List集合</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;一号&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;二号&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;三号&quot;</span>);</span><br><span class="line">Stream&lt;String&gt; stream1 = list.stream();</span><br></pre></td></tr></table></figure><ol start="2"><li>根据Set集合获取流</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream2 = set.stream();</span><br></pre></td></tr></table></figure><ol start="3"><li>根据Map集合获取流</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Map集合</span></span><br><span class="line">Map&lt;Integer,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>,<span class="string">&quot;一号&quot;</span>);</span><br><span class="line">map.put(<span class="number">2</span>,<span class="string">&quot;二号&quot;</span>);</span><br><span class="line">map.put(<span class="number">3</span>,<span class="string">&quot;三号&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 根据Map集合的键获取流</span></span><br><span class="line">Set&lt;Integer&gt; map1 = map.keySet();</span><br><span class="line">Stream&lt;Integer&gt; stream3 = map1.stream();</span><br><span class="line"><span class="comment">// 根据Map集合的值获取流</span></span><br><span class="line">Collection&lt;String&gt; map2 = map.values();</span><br><span class="line">Stream&lt;String&gt; stream4 = map2.stream();</span><br><span class="line"><span class="comment">// 根据Map集合的键值对对象获取瑞</span></span><br><span class="line">Set&lt;Map.Entry&lt;Integer, String&gt;&gt; map3 = map.entrySet();</span><br><span class="line">Stream&lt;Map.Entry&lt;Integer, String&gt;&gt; stream5 = map3.stream();</span><br></pre></td></tr></table></figure><ol start="4"><li>根据数组获取流</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 根据数组获取流</span><br><span class="line">String[] arr = &#123;&quot;一号&quot;,&quot;二号&quot;,&quot;三号&quot;&#125;;</span><br><span class="line">Stream&lt;String&gt; stream6 = Stream.of(arr);</span><br></pre></td></tr></table></figure><h3 id="Stream流的常用方法"><a href="#Stream流的常用方法" class="headerlink" title="Stream流的常用方法"></a>Stream流的常用方法</h3><h4 id="collect-Collectors-toList"><a href="#collect-Collectors-toList" class="headerlink" title=".collect(Collectors.toList())"></a>.collect(Collectors.toList())</h4><ul><li>使用map操作可以遍历集合中的每个对象，并对其进行操作，map之后，用.collect(Collectors.toList())会得到操作后的集合</li><li>使用filter()函数之后也可以通过该方法得到集合。</li><li>Collectors.toList() 用来结束Stream流</li></ul><h4 id="stream-filter"><a href="#stream-filter" class="headerlink" title="stream().filter()"></a>stream().filter()</h4><p>stream().filter()一般适用于list集合，主要作用就是条件查询，从集合中查询想要的数据。<strong>filter里面的参数user是指集合里面的每一项</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;User&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//创建3个对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        u1.setAge(<span class="number">23</span>);</span><br><span class="line">        u1.setName(<span class="string">&quot;xiaoming&quot;</span>);</span><br><span class="line">        u1.setId(<span class="number">123456</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        u2.setAge(<span class="number">26</span>);</span><br><span class="line">        u2.setName(<span class="string">&quot;xiaofang&quot;</span>);</span><br><span class="line">        u2.setId(<span class="number">77777</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">u3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        u3.setAge(<span class="number">18</span>);</span><br><span class="line">        u3.setName(<span class="string">&quot;honghong&quot;</span>);</span><br><span class="line">        u3.setId(<span class="number">11111</span>);</span><br><span class="line">        <span class="comment">//添加对象到集合</span></span><br><span class="line">        list.add(u1);</span><br><span class="line">        list.add(u2);</span><br><span class="line">        list.add(u3);</span><br><span class="line">        <span class="comment">//条件筛选</span></span><br><span class="line">        compare(list);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">compare</span><span class="params">(List&lt;User&gt; list)</span> &#123;</span><br><span class="line">        <span class="comment">//在集合中查询用户名为xiaofang的集合</span></span><br><span class="line">        List&lt;User&gt; userList = list.stream().filter(user -&gt; <span class="string">&quot;xiaofang&quot;</span>           .equals(user.getName())).collect(Collectors.toList());</span><br><span class="line">        </span><br><span class="line">        System.out.println(list);</span><br><span class="line">        System.out.println(userList);</span><br><span class="line">        </span><br><span class="line">        List&lt;User&gt; userList1 = list.stream().filter(user -&gt; user.getAge() &gt; <span class="number">19</span> &amp;&amp; user.getAge() &lt; <span class="number">24</span>).collect(Collectors.toList());</span><br><span class="line">        System.out.println(userList1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>filter：筛选（里面输入的筛选的条件（ <strong>user -&gt; “xiaofang”.equals(user.getName())</strong> ）），这里的条件是查询uesr对象中name属性。</p><h4 id="stream-map"><a href="#stream-map" class="headerlink" title="stream().map()"></a>stream().map()</h4><ol><li>stream().map()提取List对象的某一列值。然后可以通过<strong>forEach</strong>方法对该对象进行循环输出</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static void printList(List&lt;User&gt; list) &#123;</span><br><span class="line">    List&lt;String&gt; userList = list.stream().map(User::getName).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    userList.forEach(u -&gt; System.out.println(u));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="stream-sorted"><a href="#stream-sorted" class="headerlink" title="stream().sorted()"></a>stream().sorted()</h4><ul><li>对list集合进行排序</li></ul><ol><li>对id进行升序排序</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printSortList</span><span class="params">(List&lt;User&gt; list)</span> &#123;</span><br><span class="line"><span class="comment">// 升序排序</span></span><br><span class="line">    List&lt;User&gt; userList = list.stream().sorted(Comparator.comparing(User::getId)).collect(Collectors.toList());</span><br><span class="line">    userList.forEach(u -&gt; System.out.println(u));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>对id进行降序排序</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printSortList</span><span class="params">(List&lt;User&gt; list)</span> &#123;</span><br><span class="line">    <span class="comment">// 降序排序</span></span><br><span class="line">    List&lt;User&gt; userList = list.stream().sorted(Comparator.comparing(User::getId).reversed()).collect(Collectors.toList());</span><br><span class="line">    userList.forEach( u - &gt;System.out.println(u));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="流的中间操作"><a href="#流的中间操作" class="headerlink" title="流的中间操作"></a><strong>流的中间操作</strong></h3><ul><li>筛选与切片<pre><code>filter：过滤流中的某些元素limit(n)：获取n个元素skip(n)：跳过n元素，配合limit(n)可实现分页distinct：通过流中元素的 hashCode() 和 equals() 去除重复元素</code></pre></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">6</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">14</span>);</span><br><span class="line"> </span><br><span class="line">Stream&lt;Integer&gt; newStream = stream.filter(s -&gt; s &gt; <span class="number">5</span>) <span class="comment">//6 6 7 9 8 10 12 14 14</span></span><br><span class="line">        .distinct() <span class="comment">//6 7 9 8 10 12 14</span></span><br><span class="line">        .skip(<span class="number">2</span>) <span class="comment">//9 8 10 12 14</span></span><br><span class="line">        .limit(<span class="number">2</span>); <span class="comment">//9 8</span></span><br><span class="line">newStream.forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="Stream对象转换为集合"><a href="#Stream对象转换为集合" class="headerlink" title="Stream对象转换为集合"></a>Stream对象转换为集合</h3><ul><li><p><strong>collect(Collectors.toList())</strong> </p></li><li><p><strong>collect(Collectors.toSet())</strong></p></li><li><p><strong>collect(Collectors.toMap())</strong></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java中list的stream流详解&quot;&gt;&lt;a href=&quot;#Java中list的stream流详解&quot; class=&quot;headerlink&quot; title=&quot;Java中list的stream流详解&quot;&gt;&lt;/a&gt;Java中list的stream流详解&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="后端" scheme="https://aliveseven.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Java" scheme="https://aliveseven.github.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
    <category term="Java" scheme="https://aliveseven.github.io/tags/Java/"/>
    
    <category term="后端" scheme="https://aliveseven.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript实现保留两位小数</title>
    <link href="https://aliveseven.github.io/posts/a625f058/"/>
    <id>https://aliveseven.github.io/posts/a625f058/</id>
    <published>2022-10-21T15:37:17.632Z</published>
    <updated>2022-10-27T12:49:00.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript实现保留两位小数"><a href="#JavaScript实现保留两位小数" class="headerlink" title="JavaScript实现保留两位小数"></a>JavaScript实现保留两位小数</h1><h2 id="四舍五入"><a href="#四舍五入" class="headerlink" title="四舍五入"></a>四舍五入</h2><ul><li>注意：保留两位小数，将数值类型的数据改变成了字符串类型</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">2.447562341</span>;</span><br><span class="line">num = num.<span class="title function_">toFixed</span>(<span class="number">2</span>); <span class="comment">// 输出结果为 2.45</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> num) <span class="comment">// string</span></span><br></pre></td></tr></table></figure><h2 id="不四舍五入"><a href="#不四舍五入" class="headerlink" title="不四舍五入"></a>不四舍五入</h2><ul><li>第一种，先把小数变整数，再除，向下取整</li><li>注意，不改变数据类型</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="number">17.79845550</span> * <span class="number">100</span>) / <span class="number">100</span> <span class="comment">// 输出结果为 17.79</span></span><br></pre></td></tr></table></figure><ul><li>第二种，当作字符串，使用正则匹配：</li><li>注意，先将数据转换为字符串，最后再转为数值类型</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span>(<span class="number">17.79845550</span>.<span class="title function_">toString</span>().<span class="title function_">match</span>(<span class="regexp">/^\d+(?:\.\d&#123;0,2&#125;)?/</span>)) <span class="comment">// 输出结果为 17.79,不能用于整数如 10 必须写为10.0000</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：如果是负数，要先转换为正数再计算，最后再转回负数</p></blockquote><h2 id="Js取float型小数点后两位数的方法"><a href="#Js取float型小数点后两位数的方法" class="headerlink" title="Js取float型小数点后两位数的方法"></a>Js取float型小数点后两位数的方法</h2><ol><li>将浮点数四舍五入，取小数点后2位</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toDecimal</span>(<span class="params">x</span>) &#123; </span><br><span class="line">    <span class="keyword">var</span> num = <span class="built_in">parseFloat</span>(x); </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isNaN</span>(num)) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&#x27;传参类型错误，请检查！&#x27;</span>) </span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    num = <span class="title class_">Math</span>.<span class="title function_">round</span>(x*<span class="number">100</span>)/<span class="number">100</span>; </span><br><span class="line">    <span class="keyword">return</span> num; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">toDecimal</span>(<span class="number">2.447562341</span>))  <span class="comment">// 输出 2.45</span></span><br></pre></td></tr></table></figure><h2 id="Js中部分对小数的操作"><a href="#Js中部分对小数的操作" class="headerlink" title="Js中部分对小数的操作"></a>Js中部分对小数的操作</h2><ol><li>丢弃小数部分,保留整数部分</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">7</span>/<span class="number">2</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><ol start="2"><li>向上取整,有小数就整数部分加1</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="number">7</span>/<span class="number">2</span>) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><ol start="3"><li>四舍五入</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="number">5.88</span>/<span class="number">2</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><ol start="4"><li>向下取整</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="number">5.88</span>/<span class="number">2</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JavaScript实现保留两位小数&quot;&gt;&lt;a href=&quot;#JavaScript实现保留两位小数&quot; class=&quot;headerlink&quot; title=&quot;JavaScript实现保留两位小数&quot;&gt;&lt;/a&gt;JavaScript实现保留两位小数&lt;/h1&gt;&lt;h2 id=&quot;四</summary>
      
    
    
    
    <category term="前端" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="JavaScript" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
    <category term="前端" scheme="https://aliveseven.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="JavaScript" scheme="https://aliveseven.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Vue开发中组件或路由渲染问题</title>
    <link href="https://aliveseven.github.io/posts/9d49a934/"/>
    <id>https://aliveseven.github.io/posts/9d49a934/</id>
    <published>2022-10-19T02:45:22.986Z</published>
    <updated>2022-10-19T02:50:19.411Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue开发中组件或路由渲染问题"><a href="#Vue开发中组件或路由渲染问题" class="headerlink" title="Vue开发中组件或路由渲染问题"></a>Vue开发中组件或路由渲染问题</h1><h2 id="Vue3中切换路由页面不展示内容，刷新后页面正常显示"><a href="#Vue3中切换路由页面不展示内容，刷新后页面正常显示" class="headerlink" title="Vue3中切换路由页面不展示内容，刷新后页面正常显示"></a>Vue3中切换路由页面不展示内容，刷新后页面正常显示</h2><p>解决办法：给路由添加key</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;RouterView v-slot=&quot;&#123; Component &#125;&quot;&gt;</span><br><span class="line">      &lt;transition name=&quot;el-fade-in&quot; &gt;</span><br><span class="line">        &lt;keep-alive&gt;</span><br><span class="line">          &lt;component :is=&quot;Component&quot; :key=&quot;key&quot; /&gt;</span><br><span class="line">        &lt;/keep-alive&gt;</span><br><span class="line">      &lt;/transition&gt;</span><br><span class="line">    &lt;/RouterView&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">import &#123; useRoute, RouterView &#125; from &#x27;vue-router&#x27;</span><br><span class="line"></span><br><span class="line">import &#123; computed &#125; from &quot;vue&quot;;</span><br><span class="line"> </span><br><span class="line">// 路由中添加key解决切换路由时页面不展示内容，刷新后才展示内容问题</span><br><span class="line">const route = useRoute();</span><br><span class="line">const key = computed(() =&gt; &#123;</span><br><span class="line">  return route.path + Math.random();</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="Vue中重新渲染组件"><a href="#Vue中重新渲染组件" class="headerlink" title="Vue中重新渲染组件"></a>Vue中重新渲染组件</h2><p>有时Vue的反应性系统还不够，需要重新渲染组件页面。</p><p>重新渲染组件有以下几个办法：</p><ul><li>重新加载整个页面</li><li>使用<code>v-if</code></li><li>使用Vue的内置<code>forceUpdate</code>方法</li><li>在组件上进行<code>key</code>更改</li></ul><p>前面两种方法暂时不建议做，这里讨论一些后面两种方法</p><h3 id="使用forceUpdate"><a href="#使用forceUpdate" class="headerlink" title="使用forceUpdate"></a>使用forceUpdate</h3><p><strong>$forceUpdate具有强制刷新的作用</strong>，在vue框架中，如果data中有一个变量:age，修改他，页面会自动更新。但如果data中的变量为<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E7%BB%84&spm=1001.2101.3001.7020">数组</a>或对象，我们直接去给某个对象或数组添加属性，页面是识别不到的。</p><p><img src="https://img-blog.csdnimg.cn/20200521144530901.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3k1MjExMjN5,size_16,color_FFFFFF,t_70#pic_center"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  data()&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">      userInfo:&#123;name:&#x27;小明&#x27;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    updateName()&#123;</span><br><span class="line">      this.userInfo.name=&#x27;小红&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  data()&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">      A:&#123;name:&#x27;Alive&#x27;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    updateA()&#123;</span><br><span class="line">      this.A.name=&#x27;Seven&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在<code>updateA</code>函数中，我们尝试给<code>A</code>对象修改值，发现页面其实并没有变化。看看解决方法</p><p><strong>方法一：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">  <span class="title function_">updateA</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">A</span>.<span class="property">name</span>=<span class="string">&#x27;Seven&#x27;</span>;<span class="comment">//在此时，确实已经将A对象修改完成</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">A</span>.<span class="property">name</span>);<span class="comment">//输出结果: Seven</span></span><br><span class="line">    <span class="variable language_">this</span>.$forceUpdate();<span class="comment">//在这里，强制刷新之后，页面的结果变为&#x27;小红&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">  <span class="title function_">updateA</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.$set(<span class="string">&#x27;A&#x27;</span>,name,<span class="string">&#x27;Seven&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改组件的key达到组件重新渲染"><a href="#修改组件的key达到组件重新渲染" class="headerlink" title="修改组件的key达到组件重新渲染"></a>修改组件的key达到组件重新渲染</h3><p><strong>这种方法是最好的</strong>，<strong>：key=‘’（此处可触发watch和update）（最优方法）</strong></p><p>给要重新渲染的组件提供一个key属性，如果key保持不变，则不会更改组件，但是如果key发生更改，Vue 就会重新渲染属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div :key=&quot;reload&quot;&gt;</span><br><span class="line">    &#123;&#123;this.message&#125;&#125;</span><br><span class="line">    &lt;v-btn @click=&#x27;Rerender&#x27;&gt;change&lt;/v-btn&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">reload</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;旧消息&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title class_">Rerender</span>() &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">message</span> = <span class="string">&#x27;新消息&#x27;</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">reload</span> += <span class="number">1</span>;  <span class="comment">// 改变reload，达到重新渲染</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rerender()被调用时，reload改变。此时，Vue将销毁组件并创建一个新组件。我们得到的是一个子组件，它将重新初始化自身并“重置”其状态。</p><h3 id="刷新整个页面（最不推荐"><a href="#刷新整个页面（最不推荐" class="headerlink" title="刷新整个页面（最不推荐"></a>刷新整个页面（最不推荐</h3><p>1、reload   2、this.$router.go(0)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Vue开发中组件或路由渲染问题&quot;&gt;&lt;a href=&quot;#Vue开发中组件或路由渲染问题&quot; class=&quot;headerlink&quot; title=&quot;Vue开发中组件或路由渲染问题&quot;&gt;&lt;/a&gt;Vue开发中组件或路由渲染问题&lt;/h1&gt;&lt;h2 id=&quot;Vue3中切换路由页面不展</summary>
      
    
    
    
    <category term="前端" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/Vue/"/>
    
    
    <category term="前端" scheme="https://aliveseven.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://aliveseven.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Promise、Generator函数、async/await异步函数的应用</title>
    <link href="https://aliveseven.github.io/posts/6e1b41e8/"/>
    <id>https://aliveseven.github.io/posts/6e1b41e8/</id>
    <published>2022-10-16T06:38:29.095Z</published>
    <updated>2022-10-27T12:34:33.485Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Promise、Generator函数、async-await异步函数的应用"><a href="#Promise、Generator函数、async-await异步函数的应用" class="headerlink" title="Promise、Generator函数、async/await异步函数的应用"></a>Promise、Generator函数、async/await异步函数的应用</h1><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h3 id="Promise是什么？"><a href="#Promise是什么？" class="headerlink" title="Promise是什么？"></a>Promise是什么？</h3><ol><li>Promise是JS中进行异步操作的新的解决方案，在旧的回调函数的形式中，当后一个异步请求的参数依赖于前一个异步请求的结果时，就会出现层层嵌套的情况，使得代码维护性变得比较差。</li><li>Promise可以很好的解决这个回调问题，then的链式调用使得Promise的结构层次很清晰，async和await能使代码的运行变成同步。</li><li>Promise支持链式调用，解决了回调地狱问题。</li></ol><p><strong>什么是回调地狱?</strong><br>回调函数嵌套调用，外部回调函数异步执行的结果是嵌套的回调执行的条件</p><p><code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）</p><p>一个 <code>Promise</code> 必然处于以下几种状态之一：</p><p><img src="https://img-blog.csdnimg.cn/20210328214248764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JpbmdiaW5nMTEyOA==,size_16,color_FFFFFF,t_70"></p><p>案例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> A = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve , reject</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;成功&#x27;</span>)</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;失败&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;A&#x27;</span>, A)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> B = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve , reject</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;失败&#x27;</span>)</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;B&#x27;</span>,B)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> C = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span>(<span class="string">&#x27;报错&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;C&#x27;</span>,C)</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h774dzl3t6j30fw07d77d.jpg"></p><ul><li>1、执行了<code>resolve</code>，Promise状态会变成<code>fulfilled</code>，即 <strong>已完成状态</strong></li><li>2、执行了<code>reject</code>，Promise状态会变成<code>rejected</code>，即 <strong>被拒绝状态</strong></li><li>3、Promise只以<code>第一次为准</code>，第一次成功就<code>永久</code>为<code>fulfilled</code>，第一次失败就永远状态为<code>rejected</code></li><li>4、Promise中有<code>throw</code>的话，就相当于执行了<code>reject</code></li></ul><h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><ol><li>Genertor 函数是es6 新增的一种异步编程的解决方案，语法和传统的函数完全不同；Genertor 函数的最大的特点就是可以交出函数的执行权，即暂停执行。</li><li>声明Genertor函数的时候，要在function关键字和函数名之间加一个星号：*，比如 function *fn()</li><li> Generator函数封装了多个内部状态，通过yield表达式定义内部状态，执行时返回一个迭代器对象。</li></ol><h3 id="Generator的使用"><a href="#Generator的使用" class="headerlink" title="Generator的使用"></a>Generator的使用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加入星号，表示Genertor函数</span></span><br><span class="line"><span class="keyword">function</span> *<span class="title function_">gen</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;Alive&#x27;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;Seven&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;goodbye&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> A = <span class="title function_">gen</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(A.<span class="title function_">next</span>())  <span class="comment">// &#123;value: &#x27;Alive&#x27;, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(A.<span class="title function_">next</span>())  <span class="comment">// &#123;value: &#x27;Seven&#x27;, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(A.<span class="title function_">next</span>())  <span class="comment">// &#123;value: &#x27;goodbye&#x27;, done: true&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(A.<span class="title function_">next</span>())  <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h778g86jtsj30lb09rtbh.jpg"></p><p>调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。</p><h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Promise、Generator函数、async-await异步函数的应用&quot;&gt;&lt;a href=&quot;#Promise、Generator函数、async-await异步函数的应用&quot; class=&quot;headerlink&quot; title=&quot;Promise、Generato</summary>
      
    
    
    
    <category term="前端" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="JavaScript" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
    <category term="前端" scheme="https://aliveseven.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="JavaScript" scheme="https://aliveseven.github.io/tags/JavaScript/"/>
    
    <category term="面试" scheme="https://aliveseven.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Vue3中reactive对象重新赋值，页面不重新渲染问题</title>
    <link href="https://aliveseven.github.io/posts/79e18b59/"/>
    <id>https://aliveseven.github.io/posts/79e18b59/</id>
    <published>2022-10-12T16:25:14.544Z</published>
    <updated>2022-10-12T16:36:18.630Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue3中reactive对象重新赋值，页面不重新渲染问题"><a href="#Vue3中reactive对象重新赋值，页面不重新渲染问题" class="headerlink" title="Vue3中reactive对象重新赋值，页面不重新渲染问题"></a>Vue3中reactive对象重新赋值，页面不重新渲染问题</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天在学习过程中用到了Element-Plus + Vue3.2来开发一个管理系统，但是在用户表格的增删改查的开发中，表格中的单条数据的编辑问题困扰了我，一开始是用ref()取定义了一个currentRow对象（单条数据）</p><p>详细见：<a href="https://element-plus.gitee.io/zh-CN/component/table.html#%E5%8D%95%E9%80%89">https://element-plus.gitee.io/zh-CN/component/table.html#%E5%8D%95%E9%80%89</a></p><p>后面在编辑的时候发现不对劲，每次编辑完再重新请求数据的时候会报下面的错误。</p><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h72yhuhfr9j31hc0sv1kx.jpg"></p><p>然后在网上找了好久也没找出解决方案来，打断点Debug弄了一个小时感觉应该是ref()它的这个问题。我指定ref()它定义了响应式的属性，</p><p>而ref()所定义的属性的更改是对变量进行了类似<strong>浅拷贝</strong>的操作，可能因为在重新请求数据库数据的时候，ref()所定义的currentRow失去了值变为null，具体是为什么我也不知道，虽然这个错误并没有影响页面的增删改查，还是没有问题，但是我觉得这样还是有点问题。</p><p>所以我改成用reactive()来定义这个currentRow，但是呢，用reactive()定义的数据再更改的时候，页面没有跟着一起渲染，这样就引出了问题了。</p><p>而reactive()则是类似<strong>深拷贝</strong>，如果重新赋值，就会丢失原来响应式对象的引用地址，<strong>变成一个新的引用地址</strong>，这个新的引用地址指向的对象是没有经过 reactive 方法处理的，<strong>所以是一个普通对象，而不是响应式对象</strong></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>我的操作的是直接用Object.assign()来解决赋值不渲染的问题</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单条的表格数据，单选</span></span><br><span class="line"><span class="keyword">var</span> currentRow = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  id : <span class="number">100</span> ,</span><br><span class="line">  username : <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  password : <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  nickname : <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  email : <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  phone : <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  address : <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">TableCurrentChange</span>(<span class="params">val : User</span>)&#123;</span><br><span class="line">  <span class="comment">// 这样给reactive赋值可以保证页面会重新渲染</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">assign</span>(currentRow,val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外呢，还有另外的方法</p><p>在定义reactive的时候，定义属性名，在后期赋值的时候，对属性名进行赋值</p><p>比如</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">components</span>:&#123;<span class="title class_">HelloWorld</span>&#125;,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;App&#x27;</span>,</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> A=<span class="title function_">reactive</span>(&#123;</span><br><span class="line">      <span class="attr">name</span>:&#123;&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">getA</span>= (<span class="params">data</span>)=&gt;&#123;</span><br><span class="line">      A.<span class="property">name</span>=data</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      getA,</span><br><span class="line">      A</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外就是我用的Object.assign()方法，</p><p>Object.assign()拷贝的是属性值，如果源对象的属性值是一个指向对象的指针，那也只拷贝那个指针。</p><p>所以如果对象的属性值为基础类型，对于通过Object.assign()拷贝的那个属性而言是<strong>深拷贝</strong>；如果对象的属性值为引用，对于通过通过Object.assign()拷贝的那个属性而言其实是<strong>浅拷贝</strong>的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Vue3中reactive对象重新赋值，页面不重新渲染问题&quot;&gt;&lt;a href=&quot;#Vue3中reactive对象重新赋值，页面不重新渲染问题&quot; class=&quot;headerlink&quot; title=&quot;Vue3中reactive对象重新赋值，页面不重新渲染问题&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="前端" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/Vue/"/>
    
    
    <category term="前端" scheme="https://aliveseven.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://aliveseven.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue3中的ref和reactive的应用</title>
    <link href="https://aliveseven.github.io/posts/cffffdfa/"/>
    <id>https://aliveseven.github.io/posts/cffffdfa/</id>
    <published>2022-10-10T02:25:26.013Z</published>
    <updated>2022-10-12T16:28:50.708Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue3中的ref和reactive的应用"><a href="#Vue3中的ref和reactive的应用" class="headerlink" title="Vue3中的ref和reactive的应用"></a>Vue3中的ref和reactive的应用</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ref和reactive是干什么用？<strong>就是把数据变成「响应式」的</strong></p><blockquote><p>Vue3中实现数据响应式，用到的是组合式API中的<code>ref</code>和<code>reactive</code>函数，不同的是<code>ref</code>函数一般定义<strong>基本类型</strong>数据，而<code>reactive</code>函数用于定义一个<strong>对象类型</strong>的响应式数据。</p></blockquote><h2 id="Vue2和Vue3中的响应式"><a href="#Vue2和Vue3中的响应式" class="headerlink" title="Vue2和Vue3中的响应式"></a>Vue2和Vue3中的响应式</h2><p>vue2的响应式是通过<strong>Object.defineProperty（数据劫持）</strong>方法，针对对象和数组有两种处理：</p><ul><li>对象: 通过defineProperty对对象的已有属性值的读取和修改进行劫持(监视/拦截)</li><li>数组: 通过重写数组更新数组一系列更新元素的方法来实现元素修改的劫持</li></ul><h2 id="ref函数"><a href="#ref函数" class="headerlink" title="ref函数"></a>ref函数</h2><ol><li><p><strong>作用</strong>: 定义一个响应式的数据</p></li><li><p><strong>语法</strong>: <code>const xxx = ref(initValue)</code></p></li></ol><ul><li>创建一个包含响应式数据的<strong>引用对象（reference对象，简称ref对象）</strong> </li><li>JS中操作数据： <code>xxx.value</code>，因为<code>ref</code> 接收参数并将其包裹在一个带有 <code>value</code> property 的对象中返回</li><li>模板中读取数据: 不需要.value，直接：<code>&lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;/div&gt;</code></li><li>本质上，ref(0) 等于 reactive( { value:0 })</li></ul><h3 id="使用事项"><a href="#使用事项" class="headerlink" title="使用事项"></a>使用事项</h3><ol><li>使用ref包装之后，需要使用.value才行进行取值和赋值操作。这就导致一个结，就是在对象起属性名时，尽可能避开有value的属性名。因为会引起混淆。</li><li><strong>响应式对象里面如果有ref包装的值类型。则Vue会实现自动拆箱</strong>，即获取值的方式是object.property，而不是object.property.value，注意：只有响应式对象会是这样，响应式数组或者Map都不能这样。</li><li>接受的数据可以是：基本类型，也可以是对象类型，<strong>基础类型</strong>靠Object.defineProperty()的get与set完成响应式，<strong>对象类型</strong>则是靠reactive函数进行辅助</li></ol><h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, reactive, toRef &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> A = <span class="title function_">ref</span>(<span class="string">&#x27;AliveSeven&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;A的ref数据:&#x27;</span>, A)</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h70lm35d0oj30wi04r40t.jpg"></p><p>改变A，要用.value来改变</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A.<span class="property">value</span> = <span class="string">&#x27;Alice&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;改变了A后：&#x27;</span>,A)</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h70lqoowz9j30u504zac6.jpg"></p><p>使用ref来声明对象类型时候：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> C = <span class="title function_">ref</span>(&#123;</span><br><span class="line">  name : <span class="string">&#x27;Nanami&#x27;</span>,</span><br><span class="line">  age : <span class="number">77</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;C的ref数据:&#x27;</span>, C)</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h70lwhwaxij30w304yjtk.jpg"></p><h2 id="reactive函数"><a href="#reactive函数" class="headerlink" title="reactive函数"></a>reactive函数</h2><ul><li><strong>作用</strong>: 定义一个<strong>对象类型</strong>的响应式数据（基本类型不要用它，要用<code>ref</code>函数）</li><li><strong>语法</strong>：const 代理对象= reactive(源对象)</li></ul><h3 id="使用事项-1"><a href="#使用事项-1" class="headerlink" title="使用事项"></a>使用事项</h3><ol><li>接收一个对象（或数组），返回一个<strong>代理对象</strong>（Proxy的实例对象，简称proxy对象）</li><li>js中操作不需要.value(与ref区别)</li><li>reactive定义的响应式数据是“深层次的”。</li><li>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。</li><li>可以使用<strong>toRef(obj)<strong>为对象中的每一个属性创建一个ref，它可以保持对原属性的响应式链接，类似于</strong>浅拷贝</strong>。<br>* </li></ol><h2 id="ref和reactive的区别"><a href="#ref和reactive的区别" class="headerlink" title="ref和reactive的区别"></a>ref和reactive的区别</h2><ol><li>ref定义对象，在js中使用时都应该.value，如果定义的对象嵌套太深，再多一层.value太冗余，而reactive则无需.value</li><li>ref定义对象类型数据，里边使用的也是reactive中的Proxy代理，不如直接使用reactive</li><li>reactive不能直接定义基本类型数据，不起作用，可以将基本类型数据整体放入一个对象中，将reactive当作Vue2中的data去使用</li><li>ref存在异步问题</li></ol><h3 id="使用案例-1"><a href="#使用案例-1" class="headerlink" title="使用案例"></a>使用案例</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> B = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Alive2&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">22</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;B的ref数据:&#x27;</span>, B)</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h70m2m9q93j30u0044wfq.jpg"></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, reactive, toRef &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> B = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Alive2&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">22</span>,</span><br><span class="line">  <span class="attr">hobby</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">type</span> : <span class="string">&quot;唱&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">type</span> : <span class="string">&quot;跳&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">type</span> : <span class="string">&quot;rap&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">type</span> : <span class="string">&quot;篮球&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;B的ref数据:&#x27;</span>, B)</span><br><span class="line"></span><br><span class="line"><span class="comment">// reactive定义的响应式数据是“深层次的”。</span></span><br><span class="line"><span class="comment">// 下面的赋值不会影响上面的结果</span></span><br><span class="line"></span><br><span class="line">B.<span class="property">name</span> = <span class="string">&#x27;Alive3&#x27;</span></span><br><span class="line">B.<span class="property">age</span> = <span class="number">99</span></span><br><span class="line">B.<span class="property">hobby</span>[<span class="number">3</span>].<span class="property">type</span> = <span class="string">&quot;ctrl&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;改变了B后：&#x27;</span>,B)</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h70mlmoifsj30xu05ptbn.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Vue3中的ref和reactive的应用&quot;&gt;&lt;a href=&quot;#Vue3中的ref和reactive的应用&quot; class=&quot;headerlink&quot; title=&quot;Vue3中的ref和reactive的应用&quot;&gt;&lt;/a&gt;Vue3中的ref和reactive的应用&lt;/</summary>
      
    
    
    
    <category term="前端" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/Vue/"/>
    
    
    <category term="前端" scheme="https://aliveseven.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://aliveseven.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>npm、yarn设置全局安装位置和缓存位置，解决C盘占用问题</title>
    <link href="https://aliveseven.github.io/posts/894ca352/"/>
    <id>https://aliveseven.github.io/posts/894ca352/</id>
    <published>2022-10-09T14:07:38.979Z</published>
    <updated>2022-10-09T14:23:31.360Z</updated>
    
    <content type="html"><![CDATA[<h1 id="npm、yarn设置全局安装位置和缓存位置，解决C盘占用问题"><a href="#npm、yarn设置全局安装位置和缓存位置，解决C盘占用问题" class="headerlink" title="npm、yarn设置全局安装位置和缓存位置，解决C盘占用问题"></a>npm、yarn设置全局安装位置和缓存位置，解决C盘占用问题</h1><h3 id="npm设置"><a href="#npm设置" class="headerlink" title="npm设置"></a>npm设置</h3><ol><li>在nodejs文件夹下创建 <code>node_global</code> 和 <code>node_cache</code> 两个文件夹。</li><li>设置npm全局安装位置：<code>npm config set prefix &quot;D:\nodejs\node_global&quot;</code></li><li>设置npm缓存位置：<code>npm config set cache &quot;D:\nodejs\node_cache&quot;</code></li><li>设置环境变量<ul><li>用户变量Path， 添加 <code>D:\nodejs\node_global</code></li><li>新建系统变量 NODE_PATH， <code>D:\nodejs\node_global\node_modules</code></li></ul></li></ol><p><img src="https://tva1.sinaimg.cn/large/008oCS7vgy1h6ze6gxlawj31hc0smhad.jpg"></p><h3 id="yarn的安装、设置和注意事项"><a href="#yarn的安装、设置和注意事项" class="headerlink" title="yarn的安装、设置和注意事项"></a>yarn的安装、设置和注意事项</h3><ol><li>安装：<code>npm i -g yarn</code></li><li>查看yarn global、yarn cache目录<ul><li>yarn global dir</li><li>yarn cache dir</li></ul></li><li>在nodejs文件夹下创建yarn文件夹，在yarn下创建 <code>global</code> 和 <code>cache</code> 文件夹。（在D盘找个位置存放就行）</li><li>设置全局安装位置和缓存位置到D盘<ul><li><code>yarn config set global-folder &quot;D:\nodejs\yarn\global</code></li><li><code>yarn config cache-folder &quot;D:\nodejs\yarn\cache</code></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;npm、yarn设置全局安装位置和缓存位置，解决C盘占用问题&quot;&gt;&lt;a href=&quot;#npm、yarn设置全局安装位置和缓存位置，解决C盘占用问题&quot; class=&quot;headerlink&quot; title=&quot;npm、yarn设置全局安装位置和缓存位置，解决C盘占用问题&quot;&gt;</summary>
      
    
    
    
    <category term="前端" scheme="https://aliveseven.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="https://aliveseven.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="NodeJs" scheme="https://aliveseven.github.io/tags/NodeJs/"/>
    
  </entry>
  
</feed>
